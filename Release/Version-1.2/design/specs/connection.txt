#include <stdio.h>
#include <stdlib.h>

#include "cell.h"
#include "database.h"
#include "narrative.h"

// #define DEBUG

//===========================================================================
//	on_event_ext
//===========================================================================
static BMTraverseCB ext_CB;
/*
	Challenge
		on event < from
*/

int
on_event_ext( char *expression, BMContext *ctx )
/*
	PROBLEM:
	1. expression => [ event, from ] => temporarily replace '<' with '\0'
	   is not thread-safe (to say the least) as it overwrites narrative.
	   See also do_input()
*/
{
	// find from in expression
	char *from = ...
	if ( strcmp( from, "." ) )
		return bm_traverse( from, ctx, ext_CB, data );
	else {
		// traverse list of active connections from this to other cells
		for ( listItem *i=ctx->this->sub[ 1 ]; i!=NULL; i=i->next ) {
			CNInstance *connection = (CNInstance *) i->ptr;
			if ( bm_hear( expression, connection, ctx ) )
				return 1;
		}
	}
	return 0;
}
static int
ext_CB( CNInstance *connection, BMContext *ctx, void *user_data )
{
	// verify connection
	if (( connection->sub[0] == ctx->this ) && (connection->sub[1])) {
		char *expression = user_data;
		if ( bm_hear( expression, connection, ctx ) )
			return BM_DONE;
	}
	return BM_CONTINUE;
}

//===========================================================================
//	bm_hear
//===========================================================================
int
bm_hear( char *expression, CNInstance *connection, BMContext *ctx )
/*
	connection: %( this, that )
*/
{
	CNInstance *that = connection->sub[ 1 ];
	if ( that == NULL ) return 0;

	CNDB *db = ctx->db; // backup db
	CNCell *cell = (CNCell *) that->sub[ 0 ];
	push context where
	   . db = cell->core->db
	   . %% = connection	// active connection*
	   . %? = as_is		// can be used in expression
	   . %< = as_is

	traverse expression in new context <<< bm_feel like

	if successful
		. overwrite db with original ctx->db in context
		. %% = NULL	// no active connection*
  IF REQUIRED	. %? is already set to result in candidate's db
  IF REQUIRED	. %< is already set to connection (which was %%)
	  otherwise
		. pop context

	return success;
}

//===========================================================================
//	bm_sound
//===========================================================================
/*
	Challenge
		in %?: *head
	Where
		%? is an entity from another CNDB
*/
CNInstance *
bm_sound( CNInstance *e, CNInstance *connection )
{
	if ( e == NULL ) return NULL;
	CNDB *src = (CNDB *) connection->sub[1]->sub[0];
	CNDB *dst = (CNDB *) connection->sub[0]->sub[0];
	listItem *stack = NULL, *backup = NULL;
	int ndx = 0;
	for ( ; ; ) {
		if (( e->sub[ ndx ] )) {
			add_item( &stack, ndx );
			addItem( &stack, e );
			e = e->sub[ ndx ];
			ndx = 0; continue;
		}
		char *p = db_identifier( e, src );
		CNInstance *instance = lookup entity corresponding to p in dst
		if ( instance == NULL ) goto FAILED;
		for ( ; ; ) {
			if (( stack )) {
				e = popListItem( &stack );
				ndx = pop_item( &stack );
				if ( ndx==0 ) {
					addItem( &backup, instance );
					ndx = 1; break;
				}
				else {
					CNInstance *sub[ 2 ];
					sub[ 0 ] = popListItem( &backup );
					sub[ 1 ] = instance;
					instance = lookup cn_instance( sub[0], sub[1] ) in dst
					if ( instance == NULL ) goto FAILED;
				}
			}
			else return instance;
		}
	}
FAILED:
	freeListItem( &stack );
	freeListItem( &backup );
	return NULL;
}

//===========================================================================
//	bm_take
//===========================================================================
/*
	Challenge
		do %?
	Where
		%? is an entity from another CNDB
*/
CNInstance *
bm_take( CNInstance *e, CNInstance *connection )
{
	if ( e == NULL ) return NULL;
	CNDB *src = (CNDB *) connection->sub[1]->sub[0];
	CNDB *dst = (CNDB *) connection->sub[0]->sub[0];
	listItem *stack = NULL, *backup = NULL;
	int ndx = 0;
	for ( ; ; ) {
		if (( e->sub[ ndx ] )) {
			add_item( &stack, ndx );
			addItem( &stack, e );
			e = e->sub[ ndx ];
			ndx = 0; continue;
		}
		char *p = db_identifier( e, src );
		CNInstance *instance = find or create entity corresponding to p in dst
		for ( ; ; ) {
			if (( stack )) {
				e = popListItem( &stack );
				ndx = pop_item( &stack );
				if ( ndx==0 ) {
					addItem( &backup, instance );
					ndx = 1; break;
				}
				else {
					CNInstance *sub[ 2 ];
					sub[ 0 ] = popListItem( &backup );
					sub[ 1 ] = instance;
					instance = find or create cn_instance( sub[0], sub[1] ) in dst
				}
			}
			else return instance;
		}
	}
}

