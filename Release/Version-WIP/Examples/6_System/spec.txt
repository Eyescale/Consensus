Data Structure
	We use tab, *tab and **tab to keep track of the path to action's current
	conditions, as follow:

		: tab : ((( tab, '\t' ), ... ), '\t' )
			*tab -----------------^

		: *tab : (((( .(*tab), (IN,$)), (ELSE_IN,$)), ... ), (ELSE_OFF,$))
			      ^------ ( %%, *tab )
	where
		$ is (( '\0', ... ), %((?,...):*s) ) /* aka. string, which
					is input (s,...) in reverse */

	and as illustrated below:
	
			**tab grows vertically
				 |
		in $ ------------+--> *tab grows horizontally
				 |
			...	 |
				 v
				in $
				else in $
					on $	<<<< CANNOT BE same level
				...
				else off $
					current conditions

	Now with current pointing to an element in *tab - so that we do have
		: tab : %( *current, ... )
	then upon a new occurrence:

	. No more than the number of tabs in *tab may have been entered
	. The same number of tabs as are in *tab must have been entered for
	  the current conditions to apply, in which case
	  . we cannot accept ELSE_XX
	  . if IN, ON, or OFF is entered then we add one tab and start new condition
	  . if DO or CL is entered then we must mark *tab, so that when we come
	    back from subsequent new condition we do not accept ELSE_XX either
	  . Note that we also do not accept ELSE_XX if last condition is ELSE
	. if less tabs than are in *tab were entered, then we do
		: tab : ( *current, ~. )
		// which btw here above would leave (ELSE_OFF,$) dangling
	  and apply the same rules as above, with the exception that here, ie.
	  after we pop, we do accept ELSE_XX iff current tab is not marked, and
	  the last condition is not ELSE

	Note: implementation follows these rules without marking

: output
	generates the following output, which represents for each action
	individually the complete set of enabling circumstances, as well
	as its direct incidence on others, when explicitely required:

	...
	--------------------------------------------------------
	IN ....
	ON ....
	ELSE IN .....
	ELSE ON .....
		IN .....
		ELSE OFF ....
		ELSE
			DO .....
			> ......
			> ......
	--------------------------------------------------------
	...

	We have %?:(( *q, ... ), (cmd,string))
	where
             : p : (( tab, ... ), '\t' )
             : q : ( take, *p )
	
	1. output all the tabs from *p going backward
             do >"%$": %(%((?,...):*p):(.,?))
	
	2. output ( cmd, string )
	   where
		cmd:	%(%?:((.,(?,.))
		string: %(%?:((.,(.,?))
	   and
	   	cmd can be singleton or pair ( ELSE, . )

	The last ( *q, ... ) list can be either

		CL ...		| or
	   or			|	... #2
	   	DO ...		|	ELSE CL ...
		> ....		| or
	   	> ....		|	... #2
	   or			|	ELSE DO ...
		CL ...   #1	|	~.
	   	ELSE DO ...	| or
				|	...
				|	ELSE CL ... #1
				|	ELSE DO ...

	1. must check to concatenate output
	2. can be any number of [ELSE] IN/ON/OFF ...

: inform
	The idea is to build the ( guard, ( trigger:(bar,on), action ) )
	corresponding to the above-described action-threads.
	We start with

		do :< guard, bar, on >: !!

	then, on the way to the action, we traverse the levels, each
	consisting of a number of
			IN	// starting the level only*
			ON	// starting the level only*
			OFF	// starting the level only*
			ELSE IN
			ELSE ON
			ELSE OFF
		* mutually exclusive
	until the last level, which is  EITHER
		of the same kind, finishing with either
			ELSE CL followed by ELSE DO
		   	ELSE CL
		   	ELSE DO	
	   OR
		solely made of either
		   	CL
			CL followed by ELSE DO
		   	DO
			DO followed by a number of >

	In order to build guard
		only the last [ELSE] IN per level may represent a condition ON
		and that is only if it is not followed at that level by ELSE .
		all prior [ELSE] IN at that level are condition OFF

		So when we meet [ELSE] IN ?
			in : condition : ? // dispose of previous candidate
				do (( %?, OFF ), *guard )
			do : condition : %?
		otherwise when we meet ELSE anything
			in : condition : ?
				do (( %?, OFF ), *guard )
				do : condition : ~.
		and when we reach the end of that level
			in : condition : ?
				do (( %?, ON ), *guard )

	For trigger
		same logic, except :event:OFF is not the same as ~.::event:ON

		So when we meet either [ELSE] ON or [ELSE] OFF ?
			in : event : ? // dispose of previous candidate
				do ( %?, *bar )
			in case [ELSE] ON
				do : event : ( %?, ON )
			else // case [ELSE] OFF
				do : event : ( %?, OFF )
		otherwise when we meet ELSE anything
			in : event : ?
				do ( %?, *bar )
				do : event : ~.
		and when we reach the end of that level
			in : event : ?
				do ( %?, *on )

	Finally for action
	    when we meet [ELSE] CL ?
		if ELSE
			apply the above-described ELSE engagement rules
			to the pending :condition:? and :event:?
		do ( *guard, ((*bar,*on),(%?,OFF)))
		if followed by ELSE DO ?
			do ( *guard, ((*bar,*on),(%?,ON)))

	    otherwise when we meet [ELSE] DO ?
		if ELSE
			apply the above-described ELSE engagement rules
			to the pending :condition:? and :event:?
			do ( *guard, ((*bar,*on), (%?,ON)))
		otherwise
			do : action : ((%?,ON)|(*guard,(*bar,*on),%|))
			then foreach following > ?
				do ( *action, %? )

	All this put together, PLUS

	1. create occurrence from string:
		do occurrence : "%(.,?)$" < %((?,...):*s)
		=> B% internally must look up string arena

	2. verify rule compliance
		"generated cannot be generating, & v.v."
		where generated means CL or >
		and generating means DO followed by >

	   So when we meet CL or > ?
		we need to ward %? against all action occurrences
	   and when we meet DO ?
		we need to ward %? against all generated occurrences

	   Note that we only need to register actions, since generated
	   occurrences are either %( *action, ? ) or (CL,.)
	   Q: do we create list or use tag?

	3. reuse existing guard or trigger
	   two guards (ube) are considered the same if we don't have
			%( ?, guard1 ):~%( ?, guard2 )
		   or	%( ?, guard2 ):~%( ?, guard1 )
	   i.e.
		in ~.: ((~%(?,guard2),guard1)?.:%(~%(?,guard1),guard2))
			// guard1 and guard2 are the same

	   and we want to perform the same test on triggers

	   We need to register all triggers and guards so that prior
	   to instantiating ( *guard, ((*bar,*on), *action ) we look
	   for existing same, and if found, we take the existing

		do : guard/bar/on : *found // take existing
		do ~( *guard/*bar/*on )	// remove previous

	  We want to implement cache in Shared Arena so that unref'd
	  shared entities can be reallocated


