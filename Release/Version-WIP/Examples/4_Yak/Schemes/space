# Yak scheme definition file
#
# Format
#	((Rule,base), ((%,identifier),'\0') )
#	(( Rule, identifier ), ( Schema, {
#		(a,(b,...((%,id),...(z,'\0'))))
#		... }))
# Description
#	Assumed to be used in conjunction with yak.story, e.g.
#	from ./EyeScale/Consensus/Release/Version-WIP/Examples/4_Yak
#		../../B% -f Schemes/space yak.story
# Caveats
#	all the following 'space' variations are passthrough filters,
#	therefore one of the following output
#		%base:{}
#		%base:{%s:{}}
#		%base:{%space:{}}
#	will be produced when the corresponding schema is used at base
#	level, and the input is neither ' ' nor '\t'

# base rule definitions - enable only one among the following

#	(( Rule, base ), ( Schema, (:%space:)) )
#	(( Rule, base ), ( Schema, (:%s:)) )
#	(( Rule, base ), ( Schema, (: :)) )
	(( Rule, base ), ( Schema, (:%term:)) )

# space rule definitions

#	(( Rule, space ), ( Schema, (: :) ))	// recommended - if must be
	(( Rule, space ), ( Schema, (:%s:) ))	// functional

# s rule definition (left-recursive alternative to ' ' using null-schema)

	(( Rule, s ), ( Schema, {
		(::)
		(:%s\ :), (:%s\t:)	// recommended - if must be
#		(:%s :)			// double pass-through - functional
	} ) )

# term rule (involving space) definitions

#	(( Rule, term0 ), ( Schema, {
	(( Rule, term ), ( Schema, {
		(:\i:)
#		(:%int:)
		(: %term :)
		(:(%term\):)		// recommended
#		(:( %term \):)		// functional
#		(:(%term \):)		// functional
#		(:( %term\):)		// functional
	} ) )

	(( Rule, term1 ), ( Schema, {
#	(( Rule, term ), ( Schema, {
		(:\i:)
#		(:%int:)
		(: %term:), (:%term :)	// functional
		(:(%term\):)
	} ) )

	(( Rule, term2 ), ( Schema, {
#	(( Rule, term ), ( Schema, {
		(:\i:)
#		(:%int:)
		(:%s%term%s:)		// functional
		(:(%term\):)
	} ) )


# int rule definition (alternative to \i)

	(( Rule, int ), ( Schema, {
		(:\d:)
		(:%int\d:) } ))

