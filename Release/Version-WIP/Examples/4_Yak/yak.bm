/*===========================================================================
|
|		yak driver Interface narrative definition
|
+==========================================================================*/
: Yak
	in : IN  // input
		in .( ?, base )
			%( . )
			in ~.: .READY
				in (.,%?): ~%(?,DONE)
					in (.,%?): ~%(?,DONE): ~%(?,READY)
					else do .READY // all feeder schemas ready
				else on ~.: . < { ~(..), %% }
					in ((.,%?),(']',(record,*)))
						do ~( %?, base )
					else in ((.,%?),('[',((record,*),.)))
						do ~( %?, base )
					else in ~.: ((.,%?),(/[[\]]/,.))
						do ~( %?, base )
					else
						do ( .., IN ) // notify traversal
						do : OUT
			else on .READY
				do ( .., READY )
			else on : input : ? < ..
				// could do some preprocessing here
				do : record : (*record,%<?>)
			else on : input : ~. < ..
				do : record : (*record,EOF)
			else on : record : .
				do ~( .READY )
		else on ~( ., base ) // FAIL
			do ( .., OUT ) // notify failure
			do : OUT
		else on : . // start base rule instance - feeding base
			do (((rule,base), (']',*record)) | {
				(((schema, %((Rule,base),(Schema,?:~'\0'))), %(%|:(.,?))), %| ),
				.( %|, base ) } )

	else in : OUT  // traversal
		.s .f .r
		in : send : ?
+
		on %! // sending notification to parent(=driver)
			in %?:( TAKE, ? )
				do (( .., TAKE ), %? )
			else in %?:( IN, ? )
				do (( .., IN ), %(((.,?),.):%(%?:(.,?))) )
			else in %?:( OUT, ? )
				do (( .., OUT ), %(((.,?),.):%(%?:(.,?))) )
			else in %?: OUT
				do ( .., OUT )
				// in this case, not waiting for response
				do :< f, send >: ~.
				do : pop : OUT
			else in %?: ( CARRY, . )
				do (( .., CARRY ), %(%?:(.,?)) )
				// in this case, not waiting for response
				do : f : ~.
				do ~( %? ) // releases send condition
				do : pop : OUT
		else on ~( %%, ? ) < .. // on parent(=driver)'s response
			in %<?:( DONE )> // no matter what
				do :< f, send >: ~.
				do : pop : OUT
			else in %?:( TAKE, . ) // after take notification
				in : pop : ? // popping anyway
					do : send : ((%?:OUT) ?: (OUT,%?))
					do : pop : ~.
				else in : push : OUT // leaving anyway
					do : send : OUT
					do : push : ~.
				else in : push : ?
					in %<?:( CONTINUE )>
						do : send : (IN,%?)
						do : push : ~.
					else
						do :< s, r >:< %?, %(%?:(.,?)) >
						do : push : (OUT,OUT)
				else in %<?:( PRUNE )>
					do : push : OUT
			else in %?:( IN, ? ) // after push notification
				do :< s, r >:< %?, %(%?:(.,?)) >
				in %<?:( PRUNE )>
					do : push : ( IN, OUT )
			else in %?:( OUT, ? ) // after pop notification
				do :< s, r >:< %?, %(%?:(.,?)) >
				in %<?:( PRUNE )>
					do : push : OUT
			do ~( %? )
-
		else on : pop : ? // argument = s terminating frame, or OUT
			in %?: OUT
				in *f: (.,?:~EOF): ~(record,*)
					in : push : . // pruning
						do : send : OUT
					else
						do :< send, push >:<( TAKE, %? ), OUT >
				else
					do :< push, %% >: ~.
					do ~( OUT, . )
					do ~( IN, . )
				do : pop : ~.
			else in ~.: ( *r, base )
				/* set s to the successor of the schema which the current r
				   fed and which started at s's finishing frame */
				in ( %(*r,?), ?:(((schema,.),%?),.) )
					in : push : ( ., OUT ) // pruning
						do :< s, r >:< %?, %(%?:(.,?)) >
						in : push : ( ?, . )
							do : push : ((%?:~IN) ? %? :)
							do ~( %?, . )
						do : pop : ~.
					else
						do : push : ~.
						// output current schema's last event, if consumed
						in ( *s:(((.,~'\0'),.),.), (']',~(record,*)) )
							do :< send, pop >:<( TAKE, %(*f:(.,?)) ), %? >
						else
							do : send : ( OUT, %? )
							do : pop : ~.
				else // no such successor: we should have (*r,base)
					do >&" *** Error: Yak: rule '%_': "
						"subscriber has no successor ***\n": %(*r:((.,?),.))
					do :< s, pop, push >: ~.
					do ( .., ERR )
			else // back to base
				// output current schema's last event, if consumed
				in ( *s:(((.,~'\0'),.),.), (']',?:~(record,*)) )
					in : push : . // pruning
						do : send : OUT
					else do :< send, pop >:<( TAKE, %? ), OUT >
				else in %?: ('[',.) // completed unconsumed
					in : f : (.,?:~EOF)
						do :< send, pop >:<( CARRY, %? ), OUT >
					else do : send : OUT
				else in ( *f, ?:~EOF )
					//right-recusive case: completes on failing next frame
					do :< send, pop >:<( CARRY, %? ), OUT >
				else do : send : OUT

		// s has rule with event to-be-consumed starting this frame => pushing or popping
		else in ( (.,?:('[',*f)):~*r, *s )
			// rule has schema starting & not finishing at the same frame => pushing
			in ?: (((.,~'\0'), %?), %(?:(.,%?):~*r,*s)): ~%(?,%?)
				in : push : . // pruning
					do :< s, r, push >:< %?, %(%?:(.,?)), (*push,OUT) >
				else do : send : ( IN, %? )
			// s has sibling starting and not finishing at s's finishing frame
			else in ?: ((.,%?), *r ): ~%(?,%?): ~*s 
				do : s : %?
			else do : pop : %?

		// s has rule with event unconsumed starting this frame => pushing or popping
		else in ( (.,?:(']',*f)):~*r, *s )
			// rule has schema starting & not finishing at the same frame => pushing
			in ?: (((.,~'\0'), %?), %(?:(.,%?):~*r,*s)): ~%(?,%?): ~%(?,('[',(*f,.)))
				in : push : . // pruning
					do :< s, r, push >:< %?, %(%?:(.,?)), (*push,OUT) >
				// output current schema's last event, providing it's not also starting
				else in *f: ~%(*s:((.,(']',?)),.)): ~(record,*)
					do :< send, push >:<( TAKE, %(*f:(.,?)) ), %? >
				else do : send : ( IN, %? )
			// s has sibling starting and not finishing at s's finishing frame
			else in ?: ((.,%?), *r ): ~%(?,%?): ~*s 
				// output current schema's last event, providing it's not also starting
				in : push : . // pruning
				else in *f: ~%(*s:((.,(']',?)),.)): ~(record,*)
					do : send : ( TAKE, %(*f:(.,?)) )
				do : s : %?
			// s has sibling starting and not finishing at s's post-finishing frame, unconsumed
			else in ?: ((.,('[',(*f,.))), *r ): ~%(?,('[',(*f,.))): ~*s
				// output current schema's last event, providing it's not also starting
				in : push : . // pruning
				else in *f: ~%(*s:((.,(']',?)),.)): ~(record,*)
					do >&"TAKE 5: %_\n": %(*f:(.,?))
					do : send : ( TAKE, %(*f:(.,?)) )
				do : s : %?
			else do : pop : %?

		else in ( *s, ?:(.,*f)) // this frame is s's last frame => popping
			// s has sibling starting and not finishing at s's finishing frame
			in ?: ((.,%?), *r ): ~%(?,%?): ~*s
				// output current schema's last event, if consumed
				in : push : . // pruning
				else in ( *s:(((.,~'\0'),.),.), (']',?:~(record,*)) )
					do : send : ( TAKE, %(%?:(.,?)) )
				do : s : %?
			else do : pop : %?

		else in ?:( *f, . ) // there is a next frame
			// output event, unless *f is a first ']' schema frame
			in : push : . // pruning
			else in *f: (.,?): ~(record,*): ~%(*s:((.,(']',?)),.))
				do : send : ( TAKE, %? )
			do : f : %?

		else on : .
			in : record : (record,*)
				do >&"(nop)\n"
				do exit
			else
				do :< s, f >:< base, (record,*) >
		else
			do : pop : OUT

	else on : ~.
		// destroy the whole record structure, including rule
		// and schema instances - all in ONE Consensus cycle
		in : record : ~(.,EOF)
			do ~( record )
		else do exit

	else on ~( record ) // next input-traversal cycle
		// reset: we do not want base rule to catch this event
		do :< record, %% >:< (record,*), IN >

	else on init
		// base rule definition must exist and have non-null schema
		in (( Rule, base ), ( Schema, ~'\0' ))
			do :< record, %% >:< (record,*), IN >
		else
			do >&"Error: Yak: base rule not found or invalid\n"
			do exit

