/*===========================================================================
|
|		yak driver Interface narrative definition
|
+==========================================================================*/
: Yak
	on init
		// base rule definition must exist and have non-null schema
		in (( Rule, base ), ( Schema, ~'\0' ))
			do :< record, %% >:< (record,*), IN >
		else
			do >&"Error: Yak: base rule not found or invalid\n"
			do exit

	else in : IN  // input
		on : . // start base rule instance - feeding base
			do (((rule,base), (']',*record)) | {
				(((schema, %((Rule,base),(Schema,?:~'\0'))), %(%|:(.,?))), %| ),
				.( %|, base ) } )
		else in .( ?, base )
			%( . )
			in ( %?, READY )
				on ( %?, READY )
					do ( .., READY )
				else on : input : ? < ..
					// could do some preprocessing here
					do : record : (*record,%<?>)
				else on : input : ~. < ..
					do : record : (*record,EOF)
				else on : record : .
					do ~( %?, READY )
			else in ( %?, DONE )
				on ~.: . < { ~(..), %% }
					do ( .., IN ) // notify traversal
					do : OUT
			else in (.,%?): ~%(?,DONE)
				in (.,%?): ~%(?,DONE): ~%(?,READY)
				else do ( %?, READY ) // all feeder schemas ready
			else do ( %?, DONE ) // all feeder schemas complete
		else on ~( ., base ) // FAIL
			do ( .., OUT ) // notify failure
			do : OUT

	else in : OUT  // traversal
		.s .f .r
		on : .
			in ~.:: record : (record,*)
				do :< s, f >:< base, (record,*) >
			else
				do >&"(nop)\n"
				do exit

		else in : send : ?
+
		on %! // sending notification to parent(=driver)
			in %?:( TAKE, ? )
				do (( .., TAKE ), %? )
			else in %?:( IN, ? )
				do (( .., IN ), %(((.,?),.):%(%?:(.,?))) )
			else in %?:( OUT, ? )
				do (( .., OUT ), %(((.,?),.):%(%?:(.,?))) )
			else in %?: OUT
				do ( .., OUT )
				// in this case, not waiting for response
				do :< f, send >: ~.
				do : pop : OUT
			else in %?: ( CARRY, . )
				do (( .., CARRY ), %(%?:(.,?)) )
				// in this case, not waiting for response
				do : f : ~.
				do ~( %? ) // releases send condition
				do : pop : OUT
		else on ~( %%, ? ) < .. // on parent(=driver)'s response
			in %<?:( DONE )> // no matter what
				do :< f, send >: ~.
				do : pop : OUT
			else in %?:( TAKE, . ) // after take notification
				in : pop : ? // popping anyway
					do : send : ((%?:OUT) ?: (OUT,%?))
					do : pop : ~.
				else in : push : OUT // leaving anyway
					do : send : OUT
					do : push : ~.
				else in : push : ?
					in %<?:( CONTINUE )>
						do : send : (IN,%?)
						do : push : ~.
					else
						do :< s, r >:< %?, %(%?:(.,?)) >
						do : push : (OUT,OUT)
				else in %<?:( PRUNE )>
					do : push : OUT
			else in %?:( IN, ? ) // after push notification
				do :< s, r >:< %?, %(%?:(.,?)) >
				in %<?:( PRUNE )>
					do : push : ( IN, OUT )
			else in %?:( OUT, ? ) // after pop notification
				do :< s, r >:< %?, %(%?:(.,?)) >
				in %<?:( PRUNE )>
					do : push : OUT
			do ~( %? )
-
		else on : pop : ? // argument = s finish frame, or OUT
			in %?: OUT
				in *f: (.,?:~EOF): ~(record,*)
					in : push : . // pruning
						do : send : OUT
					else do :< send, push >:<( TAKE, %? ), OUT >
				else
					do :< push, %% >: ~.
					do ~( OUT, . )
					do ~( IN, . )
				do : pop : ~.
			else in ~.: ( *r, base )
				/* set s to the successor of the schema which the current r
				   fed and which started at s's finishing frame */
				in ( %(*r,?), ?:(((schema,.),%?),.) )
					in : push : ( ., OUT ) // pruning
						do :< s, r >:< %?, %(%?:(.,?)) >
						in : push : ( ?, . )
							do : push : ((%?:~IN) ? %? :)
							do ~( %?, . )
						do : pop : ~.
					else
						do : push : ~.
						// output last schema event, providing it's not initial frame
						in (*s:(((.,~'\0'),.),.), (']',~(record,*)))
							do :< send, pop >:<( TAKE, %(*f:(.,?)) ), %? >
						else
							do : send : ( OUT, %? )
							do : pop : ~.
				else // no such successor: we should have (*r,base)
					do >&" *** Error: Yak: rule '%_': "
						"subscriber has no successor ***\n": %(*r:((.,?),.))
					do :< s, pop, push >: ~.
					do ( .., ERR )
			else // back to base
				// output last schema event, providing it's not initial frame
				in (*s:(((.,~'\0'),.),.), (']',~(record,*)))
					in : push : . // pruning
						do : send : OUT
					else do :< send, pop >:<( TAKE, %(*f:(.,?)) ), OUT >
				else in %?: ('[',.) // completed unconsumed
					in ?:%(*f:(.,?:~EOF))
						do :< send, pop >:<( CARRY, %? ), OUT >
					else do : send : OUT
				else in ( *f, ?:~EOF )
					//right-recusive case: completes on failing next frame
					do :< send, pop >:<( CARRY, %? ), OUT >
				else do : send : OUT

		// s has rule with event to-be-consumed starting this frame => pushing or popping
		else in ( (.,?:('[',*f)):~*r, *s )
			// rule has schema not starting & finishing both at the same frame => pushing
			in ?: ((.,%?), %(?:(.,%?):~*r,*s)): ~%(?,%?)
				in : push : . // pruning
					do :< s, r, push >:< %?, %(%?:(.,?)), (*push,OUT) >
				else do : send : ( IN, %? )
			else do : pop : %?

		// s has rule with event unconsumed starting this frame => pushing or popping
		else in ( (.,?:(']',*f)):~*r, *s )
			// rule has schema not starting & finishing both at the same frame => pushing
			in ?: ((.,%?), %(?:(.,%?):~*r,*s)): ~%(?,%?)
				in : push : . // pruning
					do :< s, r, push >:< %?, %(%?:(.,?)), (*push,OUT) >
				// output last schema event, providing it's not also starting
				else in *f: ~%(*s:((.,(']',?)),.)): ~(record,*)
					do :< send, push >:<( TAKE, %(*f:(.,?)) ), %? >
				else do : send : ( IN, %? )
			else do : pop : %?

		else in ( *s, ?:(.,*f)) // this frame is s's last frame => popping
			in %?:(.,(record,*)) // special case: null-schema
				do : pop : %?
			// s has sibling starting and not finishing at s's finishing frame
			else in ?: ( (.,%?), *r ): ~%(?,%?): ~*s
				// output current schema's last event, if consumed
				in : push : . // pruning
				else in (*s:(((.,~'\0'),.),.), (']',.))
					do : send : ( TAKE, %(*f:(.,?)) )
				do : s : %?
			else do : pop : %?

		else // moving on
			in ?:( *f, . ) // there is a next frame
				// output event, unless *f is a first ']' schema frame
				in : push : . // pruning
				else in *f: (.,?): ~(record,*): ~%(*s:((.,(']',?)),.))
					do : send : ( TAKE, %? )
				do : f : %?
			else do : pop : OUT

	else on : ~.
		// destroy the whole record structure, including rule
		// and schema instances - all in ONE Consensus cycle
		in : record : ~(.,EOF)
			do ~( record )
		else do exit

	else on ~( record ) // next input-traversal cycle
		// reset: we do not want base rule to catch this event
		do :< record, %% >:< (record,*), IN >

