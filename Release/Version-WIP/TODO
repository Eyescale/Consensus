See Also: design/story/interactive.story
TODO
	. BUG: do ~(.) also releases %% !?!?!?
	. design/story/interactive.story#TaskList
		. unnamed base entity
		. string entities "_" => in CNDB or base narrative?
		. %identifier list variables
		. [_] and & shared arena
		. <<_>> EENOC
	. interactive - advanced / as per bm-Main.txt#interactive [NTH?]
		1. import frame narrative (for execution only)
			allows to bundle multiple do actions
	 	   would use bm_parse_cmd and read_CB instead of bm_parse_ui
		   > in .
			_ <<<< bm_parse_cmd takes over
		   => user must enter tabs (?) (except first one)
		   => user must enter done to execute

		2. import narrative or narrative sections (for registration and execution)
		   => use existing Main + insert sub-root => output:
			:
			#!<sr>
				code from interactive
			#!</>
				original code
		   Options:
		   . name sub-root => enable/disable sections dynamically
		   . can also disable original code dynamically

		3. set breakpoint - using sub-narrative (?)
DONE
	. interactive - basic, see cell.c:bm_read_command()
		. support user input "do expression" => execute action
		. support graceful exit via "do exit" or ^D (EOF)
		. cnSync() except on do >_ output commands or err
	  Example:
		./B% -i
		> do toto
		> do >:.
		{ %%, toto }
		> ^D
	. extended main.c to support
		./B% -i
		./B% file.bm -i
		./B% -f file.ini -i
		./B% -f file.ini file.bm -i
	. parser.c/story.c:
		. separated bm_parse_expr and bm_parse_cmd
		. separated readStory() and bm_read()
	. extracted [NEW] story.c/story.h from narrative.c/narrative.h
	. updated design/specs/bm-Main.txt - add About interactive section
	. program.c: cleaned up cnSync()/cnUpdate()
		cf. design/specs/bm-Main.txt
	. branched Version-2.1

OPEN ISSUES
	. do :< a, b >: ({1,2},3)
		=> wrong order of assignment
	. on ~(_?_) < %% is allowed (as EENO)
		=> %<?> resp %<!> could be deprecated
		=> must verify when instantiating EENOV and %< is %%
	. instantiate.c
		scream if partial instantiation did occur
	. instantiate.c: term_CB
		no need to test filtered if ~_ or %_ or *_

NICE TO HAVE
	. make %(_) mandatory condition to use filters in do expressions
	  e.g. do ( a:b, c ) generates error, vs. do ( %(a:b), c )
	  pro: no need to check filtered in bm_instantiate traversal, nor
	       in bm_parse/actionable
	  con: makes instantiation expressions possibly a bit heavier

	. B%-struct: about reading / executing commands
		supposedly also about typedef (mostly on Remarkable)
	. NTH: see design/specs/bm-LITERAL.txt ( ..., <a,b,c> ) etc.
	. dpu-drive.story
		: mem (variable assignment & usage in formulas)
	. do { _ }	<<<< ANY expression - assignment, release, etc.
	. finish variable stack - might answer issue below
		1. in .::expression << check we don't have (*,.) >> %. ?
		2. possibly implement .locale: expression (?)
	  issue: Yak: investigate (: %term :), (:\(%term\):) kinda race condition
	. Implement
		in .:expression	// e.g. in .:: OUT
			=> rebase perso for locale definition
			=> %. new registry variable
			=> now perso should be %[ perso, registry ]
		and any identifier lookup may go through the whole stack of registries
		Requirement
			expression:~( *, . )
		Example
			in .:: state	// pushes [ perso, registry ] where perso=%.:((*,%%),state)
				.locale	// instantiates ( %., locale )
		Benefit
		. locale will be released automatically on state changes
	. .locale: expression // initialization - use cases to be determined
		on ~.				// == inactive
		    =>	on/per ~. < src		// src can be determined
	. OPT: occurrence meta-characters ?:~ => ExpressionTake post-processing
		meaning, per Term: Ternary, Filtered, Unmarked, Coupled
	. parser.c / narrative.c
		NarrativeTake: on empty narrative: return Warning and just ignore
		ProtoSet: set errnum on double-def / already registered
	. locale variables: only on 'in_' and then attached to %?
	. do : var : %?	when %? is NULL
		=> should it be equivalent to do : var : ~.
		=> currently assignment fails
	. support per condition
		complements per event < %%
		but then we'd want to allow variable names in condition
	. allow !! inside of expression instead of assignment only
		requires changes in parser.c and instantiate.c
	. ( a, b, c, ... ) translates into ((( a, b ), c ), ... )
	. extend do !!identifier( ) to do !!expression( )
	. Other EEnoRV as-is
		on ~( %<_> )
		on %<_> < .
		do !! Narrative( %<_> )
	. improve >>>> B%%: Error / Warning handling - vs. exit(-1) or repeat
	. parser.c
		. more & better error messages
		. extract bm_parser_report from parser.c => error.c ?
	. support multiple args in do input
		do < arg1, arg2, ..., argN > : "format" <
	. Design document: formalize the internal data structures, e.g.
		cell:[ [ entry:[ name, narratives:{} ], carry ], ctx:[ this, registry ] ]
	. optimization
		. Remodel occurrence->data->expression from char * to TBD
		. do_enable: without building string?
	. bm_void() - should bm_instantiate() verify expression?
		. Pros: instantiate all or nothing
		. Cons: performances
		. Alternative:
		  1. propose special execution mode (like Debug)
		  2. special do - e.g. do$ - where bm_void() is enforced
	  Current status & Decision
		. bm_instantiate() does not invoke bm_void()
		  => bm_instantiate() may do half a job (user responsibility)
	. multi-threading (pthreads)
	. restore DEBUG mode in freeCNDB() and db_update() - cf. Version-1.1

TODOC
	. %identifier' in literal or list MUST be followed by non-separator
	. write Consensus B% Version-2.0 Programming Guide
		. Reminder: instantiation may do half a job, as
		  we do not pre-check with bm_void
	. update Consensus B% Version-1.x programming guide to
		  include Version-1.2 features - as Addendum (?)
	. Version-2.0 Announcement
		. Next Step: Version-2.1 (now Version-WIP)
		  building up on 1_Schematize/yak.new example
	. Version-2.0 README.txt - document output changes
		. multiple output format supported - with vector
			e.g. do >"%s%s":<*alpha,*beta>
		. default format ("%_") appends '\n' to the resulting output
			e.g. do >: expression
			  or do >:< expression(s) >
		. format %s allows single quote to be used without requiring
		  the corresponding SCE to be instantiated
			e.g do >"%s\n":'h'	// will always work
	. CAVEAT: in Version-2.0 implementation (db_op.c)
		signals as newborn entities become to-be-released => immediately visible
		whereas released entities cannot become signals => not repeatable
	    whereas
		in Version-WIP entities can be both newborn and to-be-released, these
		entities being born as released; furthermore, released entities can be
		reborn as released, using the new combination (e,nil) x ((nil,e),nil)
	. CAVEAT: tricky usage of ~ esp. in EENO
		e.g. on ?:~toto < src
		does not mean that anything other than toto will pass
		it means that anything matching *what the caller has*
		other than toto will pass -- note that in this case we
		do not have pivot, and that the expression, since it is
		negated, will be dereferenced first in the caller
		in other words: ~instance does not mean "not this instance",
		but the set of instances other than this instance in the CNDB
		Therefore it has to be dereferenced in the caller's CNDB first,
		as EENO are external *event* occurrences, and are not supposed to
		give access to the contents of the external CNDB
	. CAVEAT: DBFirst() DBNext() do not traverse proxy.as_sub[0]^n
		=> These instances will not be found in Version-2.0 when the
		   query expression is non-pivotable
		=> Not a problem in Version-2.1 (currently WIP) as these will
		   only be created as DB_SIGNAL_OP

