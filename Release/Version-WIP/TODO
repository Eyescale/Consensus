See Also: design/new-features-and-additions.txt
TODO
	. Feature complete
		. [DONE] term~				(signal)
		. [DONE] : var : value			(assignment)
		. [DONE] : var : ~.			(un-assignment)
		. [DONE] in/on ~.: expression		(negative occurrence)
		. [DONE] ( expr ? expr : expr ) 	(ternary-operated expression)
		. TODO: do ((expr,...):sequence:)	(list/ellipsis)
	. TEST ternary operator
	. update bm-read-narrative-states.txt (in specs)
	. Pass design/story/single-thread.story
	. deprecate bm_substantiate() / db_couple()
	. bm_input()
		. on EOF should do :input:~. instead of ~(*,input)
	. --------
	. Publish as Version-1.2
		. Reorganize Examples, e.g.
			. Examples-v1.0
				. 0_TuringMachine
			. Examples-v1.1
				. 0_TuringMachine
				. 1_Schematize
			. Examples-v1.2
				. 0_TuringMachine.0
				. 0_TuringMachine.1 // using new FFI
				. 0_TuringMachine.single
				. 1_Schematize.0
				. 1_Schematize.1 // only Yak, using new FFI
		. README.txt
		. NOTE: everything is Pair, starting from [address,value]
		. need feature-list.txt / Release Notes
	. --------
	. on_event_ext
		. need to separate expression from source
			on expression < source
		  simplest is to replace occurrence with Pair
	. traversal.c
		. Handle %? when %< is set - including special case: %(%?:...)
		. ESUB(this,e,ndx) \
			( e->sub[0]==this  ? NULL : ( e->sub[!ndx] ? e->sub[ndx] : NULL ))
		. Attention: bm_context_mark, when %< is set...
	. Where to put bm_hear, bm_sound, bm_take ????
		=> could have connection.c ???
	. --------
	. Publish as Version-2.0
			. Examples-v2.0
				. 0_TuringMachine.single
				. 0_TuringMachine.head-tape
				. 0_TuringMachine.head-tape-cell
				. 0_TuringMaching.head-cell-reporter << to be written
				. 1_Schematize	// using Scheme
				. 1_Yak.0 // support Scheme files from schematize
				. 1_Yak.1 // using new Cell design
				. 2_interactive	// TBD
NTH
	. ../../Base/Examples/1_Yak
	  remove workaround in string_util.c so that we can implement StringFinish as
	  it should - see s_cmp() in include/parser_private.h. Right now if we check
	  the string mode in StringFinish then Yak crashes
		=> reimplement schemeFrame() in ../../Base/Examples/1_Yak/scheme.c
	. expression.c: bm_instantiate() - should it check bm_void() or not ?
		. Pros: instantiate all or nothing
		. Cons: performances
		. Alternative:
		  1. propose special execution mode (like Debug)
		  2. special do - e.g. do$ - where bm_void() is enabled
	. parser.c
		. multiple separating commas inside { } => reduce to one and one only
		. integrate caught in CNParserData => all flags
		. more & better error messages
		. extract bm_parser_report from parser.c => error.c ?
	. compile into .a instead of .so
	. Design document: formalize the internal data structures, e.g.
		cell:[ entry:[ name, narratives:{} ], ctx:[ this, registry ] ]
	. per proto:expression <<< where proto can be '?' or narrative-type proto
		. PER/ELSE_PER
		. also DO_PER, e.g.
			do per ?:expression
				: var : %?
		  => only ONE occurrence->data->expression?
	. multi-threading (pthreads)

DONE
	. ternary-operated expressions - see bm-TERNARY-implementation.txt
		. parser.c	- bm_parse()
		. traversal.c	- xp_verify(), bm_verify()
		. string_util.c - p_prune( PRUNE_TERNARY, p )
		. locate.c	- bm_locate_pivot(), xp_target(), bm_locate_param()
	. traversal.c - ternary operator support
		. update bm_verify for both () and %() - done
		. handle N-ary cases e.g.
			( expr ? expr ? expr : expr : expr )
			( expr ?: expr ?: expr ? expr :)
	. parser.c - ternary operator support
	 	. see bm-TERNARY-implementation.txt
	. Restored Version-WIP backward compatibility w/ Version-1.1
	  sub-narrative execution
		. [DONE] bm_operation.c: implemented operation registries & warden
		. [DONE] parser.c : lift "base-narrative-only" EN/ELSE_EN restriction
		. [DONE] context.c:
			. bm_context_set() / bm_context_clear() implementation
			. restore bm_lookup & bm_register functionality including
			  ALL ctx->registry variables
		. operate()
			. [DONE] restore LOCALE support
			. [DONE] restore EN/ELSE_EN support
		. [DONE] pass ./B% -f Test/yak.ini Test/yak
	. Parser optimization: if ( data->opt ) goto EXPR_BGN
		and: set data->opt in _expr; clear it in expr_
	. Restore sub-narratives, EN, LOCALE, and do .expression commands as per
	  Version-1.1 in parser.c - cf ./design/specs/bm-sub-narrative-EN-association.txt
		. sub-narrative proto format is
			.identifier:( expression1 )
			:( expression1 )	// pre-compiled as .this:( expression1 )
		. LOCALE are declarations
			.var1 .var2 .... .varN
		. EN / ELSE_EN are statements in the form
			%( expression2 )
			else %( expression2 )
		  these statements enable execution of all sub-narratives verifying
		  "proto:statement" - i.e. ( expression1 ):%( expression2 )
		. do .expression commands are translated at readStory() time into
			do ( identifier, expression )
		  where identifier is the one specified in the current narrative proto
		  Note that do .expression commands from the main narrative translate
		  as do (this,expression) instantiating the base entity named "this"
	. traversal.c - ternary operator support
		. updated bm_verify() to invoke p_ternary( p ) and
		  handle return value
	. string_util.c - ternary operator support
		. p_prune( P_TERNARY, p ), p_ternary( p )
		. updated p_prune( type, p) so that
		  with (new) type==P_TERNARY,
			when called on opening '(' in ( expr ? expr : expr ),
				returns on appropriate '?' [level==1] if there is
		   with type==P_TERM or type==P_FILTER
				when called past '(' in ( expr ? expr : expr ),
				returns on appropriate '?' or ':' or ')'
	. parser.c (NEW) complete
		. filterable() : replaced using COMPOUND flag
		. implemented SIGNAL interface in file format: do signal~
		. use one stack for all
		. use flags instead of level (LEVEL) and stack.level (SET)
		. support (: ) in DO expressions
		. allow \cr to act as ',' in { }
		. db_io.c eliminated - db_output() back to database.c
		. bm_read(), in story.c, supercedes previous cnLoad() and db_input()
	. narrative.c	-> story.c
		. rewrite readStory separating cmd and expr
		. transport typelse as part of type
		. complete rewrite / CNParser
		. changed CNOccurrence from [type,data:[expression,sub]] to [data:[type,expression],sub]
		. Allow base mark in condition/event expressions
		. Do not allow negated base mark - except on ~( ... ? ... )
		. Story = Registry vs. listItem
		. Deprecated sub-narrative File Format Interface
	. db_op.c
		. db_init() / db_exit() / db_in() / db_out()
		. db_update() resets nil->sub[0] to NULL
	. operation.c
		. invoke bm_context_mark(), in locate.c
		. do_input => unhacked
	. locate.c (NEW)
		. was part of context.c and traversal.c before
		. added bm_context_mark()
	. traversal.c / new BMContext definition
		. changed xp_init, bm_feel, bm_traverse, xp_traverse
		. returns CNInstance *found
		. no more bm_push_mark()
		. bm_locate becomes bm_locate_pivot, now in locate.c
	. context.c (MODIFIED)
		. BMContext:[ db, registry ] becomes [ this, registry ]
		. extracted locate functions -> locate.c
	. program.c / program.h (NEW)
		. db_init() done after new cells made active, and updated
		  once for TO_BE_MANIFESTED to become MANIFESTED
	. Base/{list.c,registry.c,string_util.c}
		=> include <stdint.h>
		=> create pop_item() in list.c
	. database.c
		. implemented db_signal() db_coupled() db_uncouple()
		. rewrote freeCNDB() using cn_prune()
		. db_couple() : no longer allow concurrent reassignments
		. implemented db_outputf( FILE *, format, ... ) using db_output()
		  used in e.g. db_instantiate() - and elsewhere...
	. registry.c, btree.c, string_util.c, etc.
		=> used proper casting - see BUG from Rob Kedoin
		+  introduced pop_item()
	. cache.h => integrated into pair.c
		=> removed cache.c cache.h
		=> everything derives from Pair


