See Also: design/story/interactive.story
TODO
[WIP]	. implement ?:(_)(_) and ?:(_){_} and !?:(_)(_) and !?:(_){_}
		=> cf. design/specs/bm-TRAVERSE-loop.txt
		+ Test
	. implement ^^ and *^^ and *^(_)
		 => traverse.c: catch ^^ and *^^
		    ^^ = current identifier / *^^ = current value
		    ?:(_)(_) and ?:(_){_} and !?:_ and (_)^
		    *^sub = bufferized value of %(%?:sub) (including *^.)
		    Note: *^_ NOT supported in ?:() - but ^^ yes
		+ Test
	. cell out => must deregister cell's "_" and UBE from story->arena
	. Test B% UBE & strings interface
	. Test string sub-narratives
	. EENOC & EEVA
	. %identifier list variables
	. cosystem init: create (.,(Status,.)) // use %% instead of Status?
	. NTH: do "occurrence" | ...
		requires own stringLookup/stringRegister in bm_arena_register()
		as we only want to compare what is inside "_"
	. NTH: errors / warnings => should ALL be in color... => centralize?

DONE
	. implemented (_)^
		. database.h => db_has_newborn( listItem *, CNDB * );
		. instantiate.c:case_( wildcard_CB )
		. traversal_termplate.h: case '!' => CB_WildCardCB
		. parser.c
		. Testing: cf Test/55-bingo_bonga
		  implemented !^:(_)(_) - so that
			if newborn_authorized
				instantiate 1st (_)
			otherwise
				instantiate 2nd (_)
	. icast stuff moved to Base/pair.h
	. fprint_expr completed - test cases
		./B% -p Test/50_carry-piped
		./B% -p Test/51_output-cosystem
		./B% -p Test/52_output-carry
		./B% -p Test/53_output-system-launch-formula
		./B% -p Test/54_pipe-hell [narrative.c: enable TEST_PIPE]
		./B% -p Examples/4_Yak/yak.bm
		./B% -f Examples/4_Yak/Schemes/calculator -p
	. parser.c
		. allow \n after '|'
		. allow ^^ and *^^ and *^sub - including *^. in DO mode
		  RESTRICTED to PIPED|CARRY and !(INFORMED|byref)
		. (_)^ - restricted to s_at(')') and LEVEL and !byref in DO mode
		  Note: byref now includes condition FOR
		  Note: not specific to PIPED|CARRY - as !?:(_)_ isn't
		. allow ?:(_) and ?:(_){_} and !?:(_)(_) and !?:(_){_} in DO mode
		  RESTRICTED to either s_at('|') or !(LEVEL|INFORMED|byref)
		  Note: not restricted to PIPED|CARRY - as could be in SET
		. Note: pipe usage RESTRICTED to LEVEL|SET|CARRY
	. allow B% to printout inifile, e.g.
		 ./B% -f Examples/4_Yak/Schemes/calculator -p
	. output: | and |{ and !!carry(...) => \n and level++
		 cf Test/51_output-system Test/52_output-carry
	. implement do { a|b } and carry( a|b )
		 => calling PipeEndCB on , } and carry )
		 cf Test/50_carry-piped
	. shared entities & shared arenas
		. retyped base entities into ( NULL, entry )
		. cell.c: bm_cell_update( cell, story )
		. context.c: bm_context_update( ctx, story )
		. db_op.c: db_update( db, parent, arena )
		. [NEW] arena.c / arena.h <= story.c, instantiate.c
		. instantiate.c: assign_string()
		. database.c: db_output()
		. instantiate.c: assign_new() => bufferized
		. UBE implemented: !! | ...
	. removed PMARK case handling in locate_pivot.c and query.c
	. REVISION-2.2: no longer authorize e.g. %(%|:(.,?))
	  as %| is nascent and, in case of carry, pertains to child context
		=> use %|^(.,?) instead	[NEW]
	  furthermore, we only allow %| when PIPED is set and we are not in
	  a dereferencing expression
		cf. design/specs/bm-PARSE-implementation.txt
	. term_CB no longer used in instantiate_traversal and eeno_feel_traversal
	  => Warning issued at run-time - using filter_CB - in cases
		do _:expression
		on/per _:expression < @@@
	. BUGFIX eenov.c / data->success now initialized
	. declared all inline as static since we compile in library
	. instantiate.c: restored literal_CB
	. traverse.c: fixed NEGATED flag mishandling => no more f_cls
	. instantiate.c, eeno_feel.c: optimized term_CB
		cf. include/traversal.h: is_filtered(term)
	. strings implementation - parser.c // cf. Test/48_string
		do "_"
		do : variable : "_"
		: "_"
	  Note: we only allow base-level instantiation and sub-narrative
	  definition, so we don't have to handle "_" in traverse.c
	. revised design/story/interactive.story: no more [_] and '&' stuff
	. removed #ifdef UNIFIED from this version - this is here to stay
	. redefined CNStory type to [ Registry *narratives, Registry *arena ]
	. interactive - basic, see cell.c:bm_read_command()
		. support user input "do expression" => execute action
		. cnSync() except on do >_ output commands or err
		. support graceful exit via "do exit" or ^D (EOF)
		  NOTE: The Main in Examples/3_TM-multi/TM-head_cell.story
		  exits on init => ^D or "do exit" will do nothing, as
		  other cells are running. "/" however does cut.
		  Examples/2_TM-single/TM-single.story has only one cell.
	  Example:
		./B% -i
		> do toto
		> do >:.
		{ %%, toto }
		> ^D
	  Note: do ~(.) also releases %% - actually it's a FEATURE (!), as
	 	do %% will rehabilitate %%, which was released - but not removed
	. extended main.c to support
		./B% -i
		./B% file.bm -i
		./B% -f file.ini -i
		./B% -f file.ini file.bm -i
	. parser.c/story.c:
		. separated bm_parse_expr and bm_parse_cmd
		. separated readStory() and bm_read()
	. extracted [NEW] story.c/story.h from narrative.c/narrative.h
	. updated design/specs/bm-Main.txt - add About interactive section
	. program.c: cleaned up cnSync()/cnUpdate()
		cf. design/specs/bm-Main.txt
	. branched Version-2.1

OPEN ISSUES
	. BUG: instantiate.c/term_CB
		if ( p_filtered(p) ) never passes but code must remain (why?)
	. ISSUE: query.c: non-pivot case: shared entities not traversed
		=> bug or feature?
	. TBD: should I call bm_arena_register directly from parser?
		=> need story always: bm_read, bm_load<<<
		benefit:
		1. support do "occurrence" | ...
		2. can replace "_" with "&address in expression
		the question being: is address entry?
		but the point is: indexed by address => no strcmp
	. do :< a, b >: ({1,2},3)
		=> wrong order of assignment
	. on ~(_?_) < %% is allowed (as EENO)
		=> %<?> resp %<!> could be deprecated
		=> must verify when instantiating EENOV and %< is %%
	. instantiate.c
		scream if partial instantiation did occur
	. eliminate term_CB - no filtering unles %_ or *_ or ~_ (parser.c)
	  1. instantiate.c => check first how many cases there are do _:xxx
	     special case: (_,~.) => want to handle it in traverse.c/Decouple
	  2. eeno_feel.c => have to check somehow in parser if filtered
		on expression:...	<<< forbidden
	  find better word than PROTECTED => EXPOSED?

NICE TO HAVE
	. replace ... with â€¦
	. extend do :_:_ | ... to ALL assignment operations, supporting
		^^ = current identifier / *^^ = current value
		?:(_)(_) and ?:(_){_} and ?!:_ and _^
		*^sub = bufferized value of %(%?:sub) (including *^.)
	. OPT: assignment: should use expression=Pair *
	. interactive - advanced / as per bm-Main.txt#interactive
	  1. import frame narrative (for execution only)
		allowing to bundle multiple do actions
	     would use bm_parse_cmd and read_CB instead of bm_parse_ui
		> in .
			_ <<<< bm_parse_cmd takes over
	     => user must enter tabs (?) (except first one)
	     => user must enter done to execute
	  2. import narrative or narrative sections (for registration and execution)
	     => use Main if existing + insert sub-root => output:
		:
		#!<sr>
			code from interactive
		#!</>
			original code
	     Options:
	     . name sub-root => enable/disable sections dynamically
	     . can also disable original code dynamically
	  3. set breakpoint
		using sub-narrative (?)
	. assignment could use %% instead of '*'
	. make %(_) mandatory condition to use filters in do expressions
	  e.g. do ( a:b, c ) generates error, vs. do ( %(a:b), c )
	  pro: no need to check filtered in bm_instantiate traversal, nor
	       in bm_parse/actionable
	  con: makes instantiation expressions possibly a bit heavier

	. B%-struct: about reading / executing commands
		supposedly also about typedef (mostly on Remarkable)
	. NTH: see design/specs/bm-LITERAL.txt ( ..., <a,b,c> ) etc.
	. dpu-drive.story
		: mem (variable assignment & usage in formulas)
	. do { _ }	<<<< ANY expression - assignment, release, etc.
	. finish variable stack - might answer issue below
		1. in .::expression << check we don't have (*,.) >> %. ?
		2. possibly implement .locale: expression (?)
	  issue: Yak: investigate (: %term :), (:\(%term\):) kinda race condition
	. Implement
		in .:expression	// e.g. in .:: OUT
			=> rebase perso for locale definition
			=> %. new registry variable
			=> now perso should be %[ perso, registry ]
		and any identifier lookup may go through the whole stack of registries
		Requirement
			expression:~( *, . )
		Example
			in .:: state	// pushes [ perso, registry ] where perso=%.:((*,%%),state)
				.locale	// instantiates ( %., locale )
		Benefit
		. locale will be released automatically on state changes
	. .locale: expression // initialization - use cases to be determined
		on ~.				// == inactive
		    =>	on/per ~. < src		// src can be determined
	. OPT: occurrence meta-characters ?:~ => ExpressionTake post-processing
		meaning, per Term: Ternary, Filtered, Unmarked, Coupled
	. parser.c / narrative.c
		NarrativeTake: on empty narrative: return Warning and just ignore
		ProtoSet: set errnum on double-def / already registered
	. locale variables: only on 'in_' and then attached to %?
	. do : var : %?	when %? is NULL
		=> should it be equivalent to do : var : ~.
		=> currently assignment fails
	. support per condition
		complements per event < %%
		but then we'd want to allow variable names in condition
	. allow !! inside of expression instead of assignment only
		requires changes in parser.c and instantiate.c
	. ( a, b, c, ... ) translates into ((( a, b ), c ), ... )
	. extend do !!identifier( ) to do !!expression( )
	. Other EEnoRV as-is
		on ~( %<_> )
		on %<_> < .
		do !! Narrative( %<_> )
	. improve >>>> B%%: Error / Warning handling - vs. exit(-1) or repeat
	. parser.c
		. more & better error messages
		. extract bm_parser_report from parser.c => error.c ?
	. support multiple args in do input
		do < arg1, arg2, ..., argN > : "format" <
	. Design document: formalize the internal data structures, e.g.
		cell:[ [ entry:[ name, narratives:{} ], carry ], ctx:[ this, registry ] ]
	. optimization
		. Remodel occurrence->data->expression from char * to TBD
		. do_enable: without building string?
	. bm_void() - should bm_instantiate() verify expression?
		. Pros: instantiate all or nothing
		. Cons: performances
		. Alternative:
		  1. propose special execution mode (like Debug)
		  2. special do - e.g. do$ - where bm_void() is enforced
	  Current status & Decision
		. bm_instantiate() does not invoke bm_void()
		  => bm_instantiate() may do half a job (user responsibility)
	. multi-threading (pthreads)
	. restore DEBUG mode in freeCNDB() and db_update() - cf. Version-1.1

TODOC
	. %identifier' in literal or list MUST be followed by non-separator
	. write Consensus B% Version-2.0 Programming Guide
		. Reminder: instantiation may do half a job, as
		  we do not pre-check with bm_void
	. update Consensus B% Version-1.x programming guide to
		  include Version-1.2 features - as Addendum (?)
	. Version-2.0 Announcement
		. Next Step: Version-2.1 (now Version-WIP)
		  building up on 1_Schematize/yak.new example
	. Version-2.0 README.txt - document output changes
		. multiple output format supported - with vector
			e.g. do >"%s%s":<*alpha,*beta>
		. default format ("%_") appends '\n' to the resulting output
			e.g. do >: expression
			  or do >:< expression(s) >
		. format %s allows single quote to be used without requiring
		  the corresponding SCE to be instantiated
			e.g do >"%s\n":'h'	// will always work
	. CAVEAT: in Version-2.0 implementation (db_op.c)
		signals as newborn entities become to-be-released => immediately visible
		whereas released entities cannot become signals => not repeatable
	    whereas
		in Version-WIP entities can be both newborn and to-be-released, these
		entities being born as released; furthermore, released entities can be
		reborn as released, using the new combination (e,nil) x ((nil,e),nil)
	. CAVEAT: tricky usage of ~ esp. in EENO
		e.g. on ?:~toto < src
		does not mean that anything other than toto will pass
		it means that anything matching *what the caller has*
		other than toto will pass -- note that in this case we
		do not have pivot, and that the expression, since it is
		negated, will be dereferenced first in the caller
		in other words: ~instance does not mean "not this instance",
		but the set of instances other than this instance in the CNDB
		Therefore it has to be dereferenced in the caller's CNDB first,
		as EENO are external *event* occurrences, and are not supposed to
		give access to the contents of the external CNDB
	. CAVEAT: DBFirst() DBNext() do not traverse proxy.as_sub[0]^n
		=> These instances will not be found in Version-2.0 when the
		   query expression is non-pivotable
		=> Not a problem in Version-2.1 (currently WIP) as these will
		   only be created as DB_SIGNAL_OP

