See Also: design/story/interactive.story

MUST DO:
	. reimplement string shared arena interface, ie.
	  replace any string in narrative with $address in arena
		  => no more messing up with ROOT expression
		  => use strcomp => allow strings everywhere
		  => in expression : on $ => knows what to do
	  => MUST update ./design/specs/bm-ARENA.txt - esp. for strings
	  starting with local base entity definition e:[ NULL, CNDB::entry ]
			that is	e.sub[1]==[ s, e ]
		  vs. e shared:	e.sub[1]==[ s, arena::ref ]!=e
	  but also how string narrative hold string entity in root->expression
	  and how we cache local shared entities in context '$' entry, which
	  . is used on cell release to flush arena - cf. program.c:cell_release()
	  . keeps not the e but the e->sub[1] where e is a shared entity -
	    cf.  context.h:bm_register_string() bm_register_ube()
	  etc.
	  + TBD: why do I store e->sub[1] in ctx->shared and not e?
		=> would facilitate bm_lookup_string()

TODO
	. issue:
		in CARRY or PIPED ^^ and *^^ are nascent => not filterable, vs.
		in switch/case they are already instantiated
	. rename *^? into *^%?
		*^ means: dereference in current assignment buffer - if there is
		*^^ means: assigner - vs. ^^ which means assignee
	. reimplement string shared arena (see above)
	. parser: forbid en command in post-frame narrative
	. feature complete Examples/6_Proto
		[ DONE ] output l%dc%d on error
		[ DONE ] handle backslash in : string => nope! these are natural!!
		[ DONE ] output system as is => in .:output
		. create data structure & output as per system model [*]
		. launch formula: must pass ((action,ON),.)->((.,OFF),.)
		. allow {ON,OFF} in query ?
		. cosystem init
		. create (.,(Status,.)) and clear guard Status -
		. capture all proxies (and subscribe) on init
		. finalize and test TM.system example (manual)
	. OPT: REALLY nice to have: design/specs/PivotQueryOptimization.spec
	. OPT: locate_pivot && query_traversal in case of **...*identifier
	. TBD: I would like to replace else on/off & etc. with
		eg. on which / off which and else on that / else off that
		but in fact can keep '&' - just need to remove else in current narrative !
		but then "else" meaning: none of the above => no clamping ??
	. TBD: ( guard ?: term ) should NOT insert guard if passes => then what?
		if just '.' => on . requires event (can be release)
		do . => in fact does nothing, same as do ~. EXCEPT in couple!
	. TBD: use cosystem names vs. proxy => change EVA definition
	       this makes the cosystem generic, ie. co-actor can be changed /
	       handy in TM Cell implementation / e.g. current cell actor
	  issue: newly assigned cosystems must know system rules and actors
	. TBD: publish %. // better than "this" ?
	. NTH: since we keep list of locally shared entities in context '$' entry
		=> bm_query() could parse them in no pivot case
	. NTH: tag list feature completion
	  . .%list < expression, ... > just adds entries to existing list
	    .%list~ < expression, ... > could be used to reset and re-initialize
	  . %list and |^tag currently cannot be used in DO and ON and PER
	    we only support tagging in condition evaluation e.g. %(expression|^tag )
	    which could be extended to cover e.g. OUTPUT, FORE, etc.
	  . Note that .%tag~ {_} only performs condition evaluation (and tagging)
	    of passed expressions, as we don't want to transport private entities
	    and we need to support .%tag~ { ^.:~%(.,(Status,?))|^guard }
	  . Do we even use .%list <_> ? idea was .%onoff < ON, OFF >
		=> see when engineering complete
		=> remove feature if not used
	. NTH: expr1.expr1 would be ( expr1, expr 2 ) => deprecate list!
	. NTH: do >format:args | format:args | format:args
	. NTH: global function scope
	. NTH: parser_macros: extract REENTER + put caught in io struct

[*] 	See under ./design/story/proto/
		system.spec - TM system external specifications
		narrative.pseudo - TM system definition
		model.file - model file format & generator specs
	  1. specify system
	  2. extract occurrences, associate cosystems
	  3. create system narrative aka. narrative.pseudo
	  4. load system model from narrative.pseudo
	  5. output system model [in html] as
		cosystem
		: action <={ trigger, guard },{ ... }=>{ occurrences } 
		: action <={ trigger, guard },{ ... }=>{ occurrences } 
		...
		cosystem 
		...
	  => allows to navigate

	Note: when I parse my pseudo-narrative
		=> I have a current guard = { conditions }
		=> I have a current trigger = ( { bar }, { on } )
		=> for all subsequent actions
			instantiate ( guard, ( trigger, %? ))
	I can make list as I go, starting with : guard : ( guard, * )
		and then do : guard : ( *guard, condition )
	so popping is easy
	and list in extenso: (((((guard, *), 1 ), 2 ), 3), etc. )

		in ?: "....."
			do %?|^guard

BUGS
	. in system.story, if ~(s) instead of (s,~.) => crash
	. do >"%(N,...):%_\n": %(N,...) => outputs { N, (N,9) }N,...)
	  => that's because parser replaces %( with default format %_
	     should actually exit on error
	. do :( A | B | C ) => deternarize memory leak!!! => test again
	  but do :( A | (B|C) ) => no problem
	. do ~({titi,toto}) accepted but what does nothing !?
	. do ~{ started, finish } to be implemented
	. do :< a, b >: ({1,2},3)
		=> wrong order of assignment
	. passthrough "this" (cf. context_rebase) not good,
	  as it is in turn passed to sub-narrative, etc.
	. TBD: query.c: non-pivot case: shared entities not traversed
		=> bug or feature?

NOTES
	. FEATURE: per-else sequences are accepted, e.g.
		per expression	// resp. per expression < .
			action	// not even required
		else // no match was found for expression
			...
	. prune_sub: no need to check level in case '.' -> '...'
	  implement prune_dot?
	. locales in occurrence narratives => (occurrence,locale)
	  should not have .ON, .OFF or use something special
	. ?:_ => invokes
		CB_WildCardCB on '?' then, having set INFORMED,
		CB_FilterCB on ':' which is kind of a contradication (?)
	  could actually skip the ':' after WildCardCB => leave INFORMED unset
	. integrate db_debug.c from Version-1.1 into db_op.c
	. Note: in the future I want to be able to
		do list:"%$"<"string"	or do list < "string"
	  so that
		do >"%$": %( list, ?:... ) outputs string
		and we have *list pointing to the last string character
		could be NULL terminated?
	  Conversely, I want to be able to make a string out of a list
	  => The string would then be stored in string arena
	  	do : handle : $(list)	or ??
	. we could have initial state %%, allowing narrative to be
	  ::
		en %(:?)
	  .: %%
		on init // optional, could be also on %% or on this
			do : base	
	  .: base
		...
	  .: &
		// post-frame

DONE
	. reimplemented fprint_expr(), now in narrative.c
		./B% -p Examples/6_System/system.story
		./B% -p Test/69_inc
		./B% -p Test/53_output-system-launch-formula
	. implemented prepocessor "unpounding" directive
		cf. Examples/6_System/lineno.bm
	  Toggling between #~# and ## allows e.g.
	  #	this is commented
	  #~#	this executes
	  #	this executes
	  ...
	  ##	this is commented
	  #	this is commented
	. switch/case implementation => cf system.NEXT
	  => parser.c, story.c:indentation_check() changes
	  => update bm_vop()
	  => operation.c:in_case() implemented the following:
	  IN_S/ON_S: meaning in/on switch
		traverse ":expression:" aka. (*,expression) and
		if passed inform lmark:[^^,*^^] / (*^^) possibly NULL
	  C_IN/C_ON: meaning case in/on
		test "expression" (possibly "~." or ".") against *^^
		=> query_switch() in the same vein as query_assignment()
	  => in_case() covers everything, invoking
		expression.c:{ bm_switch(), bm_case() } appropriately
	  NOTES
	  1. there may be several candidates matching SWITCH expression.
	     We prioritize those verifying %((*,expression),?) either in CNDB or
	     in log - according to in/on - unassigned only if all else failed.
	  2. *^^ NULL systematically fails all cases other than "~."
	. allowed FORE expression to be filtered and marked, e.g.
	  in Examples/6_System/system.story
		do ( '\0' |
			?:%((?,...):*s):(.,?) (%|,%?):|
				((*,*tab), (**tab, (%?,%|))) )
	  cf. PivotQueryOptimization.spec for performance win
	. parser now detects and **forbids** FILTERED expressions
	  (was: at run-time)
			do expression : expression
		as well as do ( expression : expression )
	  where the first term is not BYREF
	  cf. design/specs/bm-PARSE-implementation.txt
	. renamed traversal_flags.h into parser_flags.h
	. implemented %sub$ in output format - used in system.story
	  	do > "%(.,?)$": %((?,...):*p)
	  instead of, previously
	  	do > "%$": %(%((?,...):*p):(.,?))
		where
			*p : (( tab, ... ), '\t' )
	  cf. PivotQueryOptimization.spec for performance win
	. implemented string as output argument - e.g.
		do >"hello, %s\n": "world"
	  RESTRICTIONS: base level only - base ternary term included
	  output as-is for now => string finished on 2nd '"' encountered
	  cf expression.c:bm_output()
	. implemented in (~.:expression) as contrary condition
	  RESTRICTION: base level only - base ternary term included
	. implemented do : state |: expression (including ~.)
	. implemented ~(:?) - cf Test/73_transition-from
	. allow do : state | ...
		%| takes state, ^^ is not set (would be %%)
	  as a no brainer due to the unicity of value / assignment.
	  Note that we do not allow
		  eg. do : err | ~( nl ) to release nl
	  due to the prenascency of the piping context, not befitting
	  the release operation; but as a convenience we do allow
		  eg. do : err | { ~( nl ) } to release nl
	. reformatted function declaration as .:func( args )
	  stored internally as :func(args) to optimize do_enable and
	  do_enable_x traversals, yet hidden by narrative_output
	. allowed narrative definition as .:expression to
	  	avoid unnecessary .this:expression
		allow identifier as expression
	. implemented bm_lookup_string() looking up local "$" registry
	  Note that string needs to be registered to be found, and
	  that string needs to terminate expression as we use strcmp
	  (would be easy to change as we keep the double-quotes)
		=> we could provide general support for string entities
		=> wait for redesign to be completed
	. FIXED: ellipsis no longer accepted unless SUB_EXPR in FORE
	. support ?:%(_)_ in FORE
	. implemented :| - cf instantiate.c:loop_CB()
	  upon (_):| %| takes current data->sub[NDX], ***even if NULL***
	  RESTRICTIONS:
	  only supported in instantiation, iff
	  	. preceded and followed by ) => must be _):|) alt. _):| )
		. as terminating a piped expression => must be (_| _(_):|)
	  and pass through unless (_| ?:(_)(_):| ) and actually looping
	  cf Test/69_inc_dec
	  Note: we don't inforce FORE as preceding but we could, ie.
		parser.c in "?:(_)" on '(' set some flag, but which?
	. rename traverse_data into traversal everywhere
	. FIXED: prune.c:prune_list()
		ASSUME starting on ellipsis
		RETURN on first non-backslashed ')' or '(' or '\0'
	. replaced all lookupIfThere/addIfNotThere sequences w/ addIfNotThere
	. operation:bm_vop() cf. debug.c
	. BUGFIX: query.c:xp_traverse() pvi set apart to be freed at the end
	. do { ..., ~( expression ), ... } now invokes bm_release( expression )
	  Note: only if is_f(SET) and !is_f(VECTOR|LEVEL|SUB_EXPR) nor carry
	. function expression // aka. function call - considered EN occurrence
	  RESTRICTION: expression must start with '%' or '('
	  See implementation in cell.c:bm_cell_operate() where
	  . we preserve caller's context into func (including variable perso)
	    REMINDER: perso usage is limited to locale declaration i.e.
	    .locale will instantiate ( perso, locale ) if it does not exist,
	    and allows it to be referenced as locale
	    .( expression ) references or instantiate ( perso, expression )
	    There is currently no way for the user to query perso directly
	    Base narrative perso is %%
	  . the execution order guarantees ( narrative, perso, func, instance )
	    unicity, which means for instance that the same function( instance )
	    may be invoked multiple times so long as it's from a different
	    ( narrative, perso ) context (can be same perso different narrative)
	  cf. Test/68_func
	. .:function ( parameters ) // function definition
	  RESTRICTION: func multiple definitions allowed but not executed
		as operation.c:do_enable() returns on first match
	. implemented sub-mark optimization - cf. new design / double trigger
		allow (_)^(.,.)	to enable sub-mark
		allowing !^(?,.) or !^(.,?) or !^(?,?) or !^(.,.)
			to precondition instantiation loop
		or branch e.g. !^(?,.):(1)(2) means
			if mark.sub[ 0 ] has newborn then do 1 else do 2
			cf. Test/55_bingo-bonga
		Note that in include/traversal.h
			)^_ invokes CB_NewBornCB, on the caret
			!^_ invokes CB_WildCardCB, on the exclamation mark
	. implemented
		in ?: "string"	// cf. Test/67_in-str
	  in addition to
		do "string"
		do : variable : "string"
		: "string" // narrative
	. implemented post-frame narrative - cf. Test/66_post-frame
	  affected cell.c: bm_cell_operate(), operation.c: do_enable()
	. removed restriction whereby tag needed to be declared before use:
	  tag names are now memory allocated, so no need to declare them before use
	  note: declaration is still supported and will pre-allocate tag
	  cf. Test/64_tag-use-cases
	. created Examples/3_TM.multi/{ TM-tape_drive.story, TM-htc.story }
		  new Cell centralized in Tape class
	. extended *^?:sub to return
	  EITHER - if %?:sub is an assignee in the current assignment occurrence
		the assigned value of %?:sub in the current assignment buffer
	  OR - if %?:sub is not an assignee in the current assignment occurrence
		%?:sub itself
	  BUGFIX Test/58_EYEYE-ube
	. BMContext entry: name can either be identifier or one separator
		'^' represents "^." in expression = tag current value
		':' represents "^^" in expression = current assignee
		';' represents "*^?" in expression = assignment buffer
	. BUGFIX query.c:xp_verify()
		Tests DBStarMatch( x->sub[0]->sub[0] ) before subbing exponent
	  cf. Test/65_star-mark
	. parser.c: reallowed ~.. and ~.identifier
	. System init spec - see design/story/interactive.story
	. upgraded Test/09_pipe to %|:sub instead of %(%|:sub) <<< deprecated
	. bugfix operation.c:do_enable() cf. Test/48_string
	. REVISION 2.2: deprecated %(_) => use en _
	. removed Test/47_do-ellipsis - file was garbage (?)
	. fprint_output: air-space output vector - cf Test/64_tag-use-cases
	. errout.c: centralized error messages
	. implemented .%tag expressions
		.%tag	// declaration and registration
		.%tag  <_> // inform tag, e.g.: .%tag <ON,OFF>
		.%tag  { expression(^.)|^.~, ... } // foreach, |^.~ => clip
		.%tag~ { expression(^.)|^., ... } // while pop |^. => save
		.%tag~ // flush and deregistration
	  RESTRICTIONS
		neither %tag nor ^tag can be used inside of expression(^.)
		%list and ^list cannot be both in the same expression
		^. only allowed in *type&LOCALE and is_f(SET) - ie.
			.%tag{_} or .%tag~{_} above
	  cf. Test/63_tag-list-op
	. implemented %list and |^list and |^list~
	  RESTRICTION:
		%list and ^list cannot be both in the same expression
	  => traversal.h: %list => RegisterVariableCB
			DONE	locate_pivot.c:	register_variable_CB
			DONE	instantiate.c:	register_variable_CB
			DONE	eeno_query.c:	match_CB => bm_match()
			DONE	query.c:	match_CB => bm_match()
	  => traversal.h: |^list and |^list~ => BgnPipeCB
			DONE	query.c: using filter_CB
	. registry.h: renamed IndexedByCharacter into IndexedByNameRef
	. eeno_query.c: renamed bm_proxy_scan into bm_eeno_scan
	. allow %?:sub and %!:sub when *type&DO and !byref
		=> allows e.g. %?:(.,?) without %(%?:(.,?)) in these cases
		=> is PROTECTED: cannot be filtered nor used as ternary guard
	  cf. Test/53_output-system-launch-formula [updated]
	  cf. Test/61_instantiate-rvsub
	. allow _< ?:{_} // cf. parser.c and eeno_query.c: bm_eeno_scan()
	. extracted bm_parse_eenov, bm_parse_char, bm_parse_regex, bm_parse_seq
	  from parser.c - Note:
	  	~.?	not allowed
		~.:	must be written verbatim (no space)
		~.(	must be written verbatim (no space)
		?:...	must be written verbatim (no space)
	. RE-REVISION 2.2: using %|:sub instead of %|^sub - more understandable
	. implemented %(_)^ use case, as per design/story/interactive.story
	  => instantiate.c: collect_CB uses bm_list_inform() which first tests
	     results via bm_intake so as to set data->newborn.current flag
	. p_prune( PRUNE_TERM, p ) now returns on '^' if follows ')'
	. p_prune( PRUNE_LEVEL, p ) / integrated in prune.c / handles '^'
	. bm_traverse(): handles '^' use cases:
		*^	=> *^^	& DereferenceCB alt. p++ to ^^
			   *^? 	& DereferenceCB alt. p++ to ^?
		^.	=> INFORMED & RegisterVariableCB alt. p+=2; set INFORMED
		^^	=> INFORMED & RegisterVariableCB alt. p+=2; set INFORMED
		^?	=> following *
		)^	=> INFORMED & NewBornCB / p++ past )^
		|^	=> BgnPipeCB alt. skip |^_~
	. parser: (_)^ PROTECTED => cannot be followed by ':' nor be ternary guard
	. deternarize no longer optimizes any of ?:(_)(_) or !^:(_)(_) or (_)^
		=> parser.c: does not allow ternary in FORE
		=> deternarize.c: does not optimize if )(_) or )^
	. bugfix ?:(_){_} => traversal.h
		. on )(_) skip to the last closing parenthesis - for !^:(_)(_)
		. bugfix markscan - for ?:(_)(_) and ?:(_){_}
		  on (_) or {_} when BASE and INFORMED => traverse_data->done = 1
		  allows markscan / bm_query() to return after FORE
	  cf Test/56_Loop
	. bm_arena_flush() and freeArena() invoke cn_prune vs. cn_release
	. implemented EEVA as %<.> - we do not implement EENOC in this release
		=> parser.c: %<.> RESTRICTED to ( *type&IN || is_f(SUB_EXPR) )
		=> locate_pivot.c: ignore %<.>
		=> eenov.c: implemented eeva( CNInstance *, CNDB * )
	  cf. Test/60_EEVA
	. NOTE: strings are not authorized in inifile as we may not have a story
	  at that stage.
	. Story Arena
		. retype arena into e.g. [ string, ube ]
		. cache sub-narrative string in n->root->data->expression
		. register shared entities in context's "$" entry
		. implement cell-out and bm_arena_flush()
	. bm_arena_register: manifest new instantiated entities
	. string sub-narratives
		cf. Test/59_string-sub-narrative
	  Note: ultimately strings will be allocated in B% process arena,
		- and replaced in narrative occurrences with their addresses -
		so that testing will not involve strcmp()
	. on ~(_?_) < %% is allowed (as EENO)
		=> %<?> resp %<!> could be deprecated
		=> must verify when instantiating EENOV and %< is %%
		=> DONE: cf. cell.c:bm_inform()
	. Shared entities comparison/translation/transposition [DONE]
		database.c: outputf - DBIdentifier(e)
			    db_match => bm_arena_compare()
		cell.c: bm_inform => bm_arena_transpose()
			bm_intake => bm_arena_translate()
		eenov.c: identifier_CB => db_match_identifier( x, p )
		context.c: bm_match => db_match_identifier( x, p )
	. re-fixed "?:" in eeno_query => using wildcard_CB to skip "?:"
	. moved bm_inform() and bm_intake() from context.c to cell.c
	. NOTE: do :_:!! |{ here %| is *^^, not the whole set of UBE's }
	. implement ^^ and *^^ and *^?:sub (including *^?)
	  in instantiate.c: inform_carry and inform_UBE, we do
		registryRegister( ctx, ";", (Registry *) buffer );
		for ( ... ) { // where current is entry in buffer
			registryRegister( ctx, ":", (Pair *) current ); }
	  in include/traversal.h, we associate
		^^  			=> CB_RegisterVariableCB
		*^^ / *^?:(_) / *^?	=> CB_DereferenceCB
	  *^_ is only authorized as term in the actionable part of DO expressions
		instantiate_traversal	=> collect_CB // DONE: bm_scan()
	      where
		*^?:sub = bufferized value of %(%?:sub) (including *^?)
		DONE: bm_scan() now invokes bm_context_lookup() to extract value
	  ^^ is queryable => wherever BMRegisterVariableCB is defined, that is:
		eeno_feel_traversal.h		N/A
		instantiate_traversal.h		register_variable_CB // DONE: default
		locate_pivot_traversal.h	register_variable_CB // DONE: EYEYE
		query_traversal.h		match_CB // DONE: lookup_rv()
	  Test ^^ *^^ and *^? *^?:(_)
		cf Test/58_EYEYE-ube
	. unrestricted ^^ - aka. EYEYE: generally means: current assignee
	. instantiate.c: on "}|)," handle sub[ NDX ]==NULL
		that is: pipe_bgn_CB, close_CB, end_set_CB, comma_CB
		=> no more _return( 2 ) but instead pruning levels
		   with possibility to recover from NULL results
	. redefined _prune( take ) as _prune( take, p )
	. BUGFIX: context.c: mark_sub() only applies mark's exponent's subs
		=> '?' requires %(_) arround starred expression
	. p_prune( PRUNE_TERM ) returns on '|' => using _prune( BM_PRUNE_LEVEL )
	. implement per expression
	. implement ?:(_)(_) and ?:(_){_} and !?:(_)(_) and !?:(_){_}
		=> cf. design/specs/bm-TRAVERSE-loop.txt
		+ Test: cf. Test/56_FORE
	. BUGIX locate_pivot.c => now using not_CB
		Note that in traversal.h NEGATED only applies
		to term - i.e. is NOT passed inside (_)
	. redesigned context.c:bm_mark() and operation.c interface
	. implemented (_)^
		. database.h => db_has_newborn( listItem *, CNDB * );
		. instantiate.c:case_( wildcard_CB )
		. traversal.h: case '!' => CB_WildCardCB
		. Testing: cf Test/55-bingo_bonga
		  implemented !^:(_)(_) - so that
			newborn_authorized => instantiate 1st (_)
			otherwise => instantiate 2nd (_)
	. icast stuff moved to Base/pair.h
	. fprint_expr completed - test cases
		./B% -p Test/50_carry-piped
		./B% -p Test/51_output-cosystem
		./B% -p Test/52_output-carry
		./B% -p Test/53_output-system-launch-formula
		./B% -p Test/54_pipe-hell [narrative.c: enable TEST_PIPE]
		./B% -p Examples/4_Yak/yak.bm
		./B% -f Examples/4_Yak/Schemes/calculator -p
	. parser.c
		. allow \n after '|'
		. allow ^^ - aka. EYEYE
		  UNRESTRICTED - generally means current assignee => can be NULL
		. allow *^^ and *^?:sub - including *^? in DO mode
		  RESTRICTED to PIPED|CARRY and !(INFORMED|byref)
		. (_)^ - restricted to s_at(')') and LEVEL and !byref in DO mode
		  Note: byref now includes condition FOR
		  Note: not specific to PIPED|CARRY - as !?:(_)_ isn't
		. allow ?:(_) and ?:(_){_} and !?:(_)(_) and !?:(_){_} in DO mode
		  RESTRICTED to either s_at('|') or !(LEVEL|INFORMED|byref)
		  Note: not restricted to PIPED|CARRY - as could be in SET
		. Note: pipe usage RESTRICTED to LEVEL|SET|CARRY
	. allow B% to printout inifile, e.g.
		 ./B% -f Examples/4_Yak/Schemes/calculator -p
	. output: | and |{ and !!carry(...) => \n and level++
		 cf Test/51_output-system Test/52_output-carry
	. implement do { a|b } and carry( a|b )
		 => calling PipeEndCB on , } and carry )
		 cf Test/50_carry-piped
	. shared entities & shared arenas
		. retyped base entities into ( NULL, entry )
		. cell.c: bm_cell_update( cell, story )
		. context.c: bm_context_update( ctx, story )
		. db_op.c: db_update( db, parent, arena )
		. [NEW] arena.c / arena.h <= story.c, instantiate.c
		. instantiate.c: assign_string()
		. database.c: db_output()
		. instantiate.c: assign_new() => bufferized
		. UBE implemented: !! | ...
	. removed PMARK case handling in locate_pivot.c and query.c
	. REVISION-2.2: no longer authorize e.g. %(%|:(.,?))
	  as %| is nascent and, in case of carry, pertains to child context
		=> use %|^(.,?) instead	[NEW]
	  furthermore, we only allow %| when PIPED is set and we are not in
	  a dereferencing expression
		cf. design/specs/bm-PARSE-implementation.txt
	. term_CB no longer used in instantiate_traversal and eeno_feel_traversal
	  => Warning issued at run-time - using filter_CB - in cases
		do _:expression
		on/per _:expression < @@@
	. BUGFIX eenov.c / data->success now initialized
	. declared all inline as static since we compile in library
	. instantiate.c: restored literal_CB
	. traverse.c: fixed NEGATED flag mishandling => no more f_cls
	. instantiate.c, eeno_feel.c: optimized term_CB
		cf. include/traversal.h: is_filtered(term)
	. strings implementation - parser.c // cf. Test/48_string
		do "_"
		do : variable : "_"
		: "_"
	  Note: we only allow base-level instantiation and sub-narrative
	  definition, so we don't have to handle "_" in traverse.c
	. revised design/story/interactive.story: no more [_] and '&' stuff
	. removed #ifdef UNIFIED from this version - this is here to stay
	. redefined CNStory type to [ Registry *narratives, Registry *arena ]
	. interactive - basic, see cell.c:bm_read_command()
		. support user input "do expression" => execute action
		. cnSync() except on do >_ output commands or err
		. support graceful exit via "do exit" or ^D (EOF)
		  NOTE: The Main in Examples/3_TM-multi/TM-head_cell.story
		  exits on init => ^D or "do exit" will do nothing, as
		  other cells are running. "/" however does cut.
		  Examples/2_TM-single/TM-single.story has only one cell.
	  Example:
		./B% -i
		> do toto
		> do >:.
		{ %%, toto }
		> ^D
	  Note: do ~(.) also releases %% - actually it's a FEATURE (!), as
	 	do %% will rehabilitate %%, which was released - but not removed
	. extended main.c to support
		./B% -i
		./B% file.bm -i
		./B% -f file.ini -i
		./B% -f file.ini file.bm -i
	. parser.c/story.c:
		. separated bm_parse_expr and bm_parse_cmd
		. separated readStory() and bm_read()
	. extracted [NEW] story.c/story.h from narrative.c/narrative.h
	. updated design/specs/bm-Main.txt - add About interactive section
	. program.c: cleaned up cnSync()/cnUpdate()
		cf. design/specs/bm-Main.txt
	. branched Version-2.1

NICE TO HAVE
	. do "occurrence" | ...
	  requires own stringRegister/stringLookup in bm_arena_register()
	  as we only want to compare what is inside "_"
	. implement p_prune() using bm_traverse() ?
		. pros: less complexity in Base + consistent w/ code
		. cons: test each character
	. byref vs. BYREF (traversal flag of its own)
	  issue: major compatibility breach
	. query, scan, feel, etc. could take &p as argument, so that
	       on return we have p = post-expression
	. replace ... with …
	. extend do :_:_ | ... to ALL assignment operations, supporting
		^^ = current assignee / *^^ = current value
		?:(_)(_) and ?:(_){_} and ?!:_ and _^
		*^?:sub = bufferized value of %(%?:sub) (including *^?)
	. OPT: assignment: should use expression=Pair *
	. interactive - advanced / as per bm-Main.txt#interactive
	  1. import frame narrative (for execution only)
		allowing to bundle multiple do actions
	     would use bm_parse_cmd and read_CB instead of bm_parse_ui
		> in .
			_ <<<< bm_parse_cmd takes over
	     => user must enter tabs (?) (except first one)
	     => user must enter done to execute
	  2. import narrative or narrative sections (for registration and execution)
	     => use Main if existing + insert sub-root => output:
		:
		#!<sr>
			code from interactive
		#!</>
			original code
	     Options:
	     . name sub-root => enable/disable sections dynamically
	     . can also disable original code dynamically
	  3. set breakpoint
		using sub-narrative (?)
	. assignment could use %% instead of '*'
	. make %(_) mandatory condition to use filters in do expressions
	  e.g. do ( a:b, c ) generates error, vs. do ( %(a:b), c )
	  pro: no need to check filtered in bm_instantiate traversal, nor
	       in bm_parse/actionable
	  con: makes instantiation expressions possibly a bit heavier

	. B%-struct: about reading / executing commands
		supposedly also about typedef (mostly on Remarkable)
	. NTH: see design/specs/bm-LITERAL.txt ( ..., <a,b,c> ) etc.
	. dpu-drive.story
		: mem (variable assignment & usage in formulas)
	. do { _ }	<<<< ANY expression - assignment, release, etc.
	. finish variable stack - might answer issue below
		1. in .::expression << check we don't have (*,.) >> %. ?
		2. possibly implement .locale: expression (?)
	  issue: Yak: investigate (: %term :), (:\(%term\):) kinda race condition
	. Implement
		in .:expression	// e.g. in .:: OUT
			=> rebase perso for locale definition
			=> %. new registry variable
			=> now perso should be %[ perso, registry ]
		and any identifier lookup may go through the whole stack of registries
		Requirement
			expression:~( *, . )
		Example
			in .:: state	// pushes [ perso, registry ] where perso=%.:((*,%%),state)
				.locale	// instantiates ( %., locale )
		Benefit
		. locale will be released automatically on state changes
	. .locale: expression // initialization - use cases to be determined
		on ~.				// == inactive
		    =>	on/per ~. < src		// src can be determined
	. OPT: occurrence meta-characters ?:~ => ExpressionTake post-processing
		meaning, per Term: Ternary, Filtered, Unmarked, Coupled
	. parser.c / narrative.c
		NarrativeTake: on empty narrative: return Warning and just ignore
		ProtoSet: set errnum on double-def / already registered
	. locale variables: only on 'in_' and then attached to %?
	. do : var : %?	when %? is NULL
		=> should it be equivalent to do : var : ~.
		=> currently assignment fails
	. support per condition
		complements per event < %%
		but then we'd want to allow variable names in condition
	. allow !! inside of expression instead of assignment only
		requires changes in parser.c and instantiate.c
	. ( a, b, c, ... ) translates into ((( a, b ), c ), ... )
	. extend do !!identifier( ) to do !!expression( )
	. Other EEnoRV as-is
		on ~( %<_> )
		on %<_> < .
		do !! Narrative( %<_> )
	. improve >>>> B%%: Error / Warning handling - vs. exit(-1) or repeat
	. parser.c
		. more & better error messages
		. extract bm_parser_report from parser.c => error.c ?
	. support multiple args in do input
		do < arg1, arg2, ..., argN > : "format" <
	. Design document: formalize the internal data structures, e.g.
		cell:[ [ entry:[ name, narratives:{} ], carry ], ctx:[ this, registry ] ]
	. optimization
		. Remodel occurrence->data->expression from char * to TBD
		. do_enable: without building string?
	. bm_void() - should bm_instantiate() verify expression?
		. Pros: instantiate all or nothing
		. Cons: performances
		. Alternative:
		  1. propose special execution mode (like Debug)
		  2. special do - e.g. do$ - where bm_void() is enforced
	  Current status & Decision
		. bm_instantiate() does not invoke bm_void()
		  => bm_instantiate() may do half a job (user responsibility)
	. multi-threading (pthreads)
	. restore DEBUG mode in freeCNDB() and db_update() - cf. Version-1.1
	. really think about
		on init <=> on ( %% )
		do exit <=> do ~( %% )
	  => we have
		nil:( NULL, NULL ) as it should <<< actually could be anything I want >>>>
	  	%%:( ( NULL, (CNCell*) this ), NULL )
				^------	( [ entry:narrative, carry:NULL ], ctx )
	          db:[ nil, ndx ] -----------------------------------------^
			     ^----------------- registries ----------------^
		Why not separate CNDB and ctx ? Because I want access to db from ctx !
	  The thing I am interested in being the relationship between %% and nil

TODOC
	. cf. Test/37_include: path is relative to the story file path,
	  not to the current B% working directory
	. [sub]narrative definition CAN start at tab 0 after declaration
	. active registry not verified on event < *src
	  when specified directly, *src is not required to be in %@ for EENO to perform
	. %identifier' in literal or list MUST be followed by non-separator
	. write Consensus B% Version-2.0 Programming Guide
		. Reminder: instantiation may do half a job, as
		  we do not pre-check with bm_void
	. update Consensus B% Version-1.x programming guide to
		  include Version-1.2 features - as Addendum (?)
	. Version-2.0 Announcement
		. Next Step: Version-2.1 (now Version-WIP)
		  building up on 1_Schematize/yak.new example
	. Version-2.0 README.txt - document output changes
		. multiple output format supported - with vector
			e.g. do >"%s%s":<*alpha,*beta>
		. default format ("%_") appends '\n' to the resulting output
			e.g. do >: expression
			  or do >:< expression(s) >
		. format %s allows single quote to be used without requiring
		  the corresponding SCE to be instantiated
			e.g do >"%s\n":'h'	// will always work
	. CAVEAT: in Version-2.0 implementation (db_op.c)
		signals as newborn entities become to-be-released => immediately visible
		whereas released entities cannot become signals => not repeatable
	    whereas
		in Version-WIP entities can be both newborn and to-be-released, these
		entities being born as released; furthermore, released entities can be
		reborn as released, using the new combination (e,nil) x ((nil,e),nil)
	. CAVEAT: tricky usage of ~ esp. in EENO
		e.g. on ?:~toto < src
		does not mean that anything other than toto will pass
		it means that anything matching *what the caller has*
		other than toto will pass -- note that in this case we
		do not have pivot, and that the expression, since it is
		negated, will be dereferenced first in the caller
		in other words: ~instance does not mean "not this instance",
		but the set of instances other than this instance in the CNDB
		Therefore it has to be dereferenced in the caller's CNDB first,
		as EENO are external *event* occurrences, and are not supposed to
		give access to the contents of the external CNDB
	. CAVEAT: DBFirst() DBNext() do not traverse proxy.as_sub[0]^n
		=> These instances will not be found in Version-2.0 when the
		   query expression is non-pivotable
		=> Not a problem in Version-2.1 as these are created as DB_SIGNAL_OP

NEXT VERSION
	. externalize System definition => bmedit or ./B% -i
	. bmedit to verify that, in B% sub-narratives
	  action-generated events cannot be (action,ON|OFF) except ( this, OFF )
	  which must be specified for actions with B% narrative

