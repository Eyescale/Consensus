
Synopsis
	bm_traverse - generic B% expression traversal

References
	definition
		traverse.c
		./include/traverse.h
	use cases
		instantiate.c	bm_instantiate()
				bm_void()
		deternarize.c	deternarize()
		locate.c	bm_locate_pivot()
				xp_target()
				bm_locate_param()
		feel.c		bm_verify()
	value
		homogenize B% (dynamic) expression traversal

Usage & Implementation
	static BMTraverseCB
		bgn_CB, preempt_CB, negated_CB, ..., identifier_CB, end_CB;
	typedef struct {
		...
	} MyDataType;
	#define case_( func ) \
		} static int func( BMTraverseData *traverse_data, char *p, int flags ) { \
			MyDataType *data = traverse_data->user_data;

	MyTakeType
	myFunc( char *expression, BMContext *ctx )
	{
		...
		MyDataType data;
		memset( &data, 0, sizeof(data) );
		// initialize my data
		
		BMTraverseData traverse_data;
		memset( &traverse_data, 0, sizeof(traverse_data) );
		traverse_data.user_data = &data;

		BMTraverseCB *table[ BMTraverseCBNum ];
		memset( table, 0, sizeof(table) );

		/* inform only those table entries for which
		   we want user-specific event processing
		*/
		BMTraverseCB **table = (BMTraverseCB **) traverse_data.table;
		table[ BMBgnCB ]	= bgn_CB;
		table[ BMPreemptCB ]	= preempt_CB;
		table[ BMNegatedCB ]	= negated_CB;
		...
		table[ BMIdentifierCB ]	= identifier_CB;
		table[ BMEndCB ]	= end_CB;

		/* invoke BMtraverse() and traverse expressions
		*/
		bm_traverse( expression, &traverse_data );
		return my_take;

		BMTraverseCBBegin
		case_( bgn_CB )
			....
			return BM_DONE or BM_CONTINUE;
		case_( preempt_CB )
			...
			return BM_DONE or BM_CONTINUE;
		case_( negated_CB )
			My code, accessing (BMTraverseData *) traverse_data
			including	traverse_data->flags
					traverse_data->p
					traverse_data->done
			      and	traverse_data->user_data
			       as	(MydDataType *) data
			...
			return BM_DONE or BM_CONTINUE;
		case_( identifier_CB )
			....
			return BM_DONE or BM_CONTINUE;
		case_( end_CB )
			....
			return BM_DONE or BM_CONTINUE;
		BMTraverseCBEnd
	}
	Where
		on return value BM_CONTINUE
			BMtraverse continues informing p and flags
		on return value BM_DONE
			BMtraverse continues without informing anything
		on traverse_data->done other than zero
			BMtraverse breaks out of its parsing loop

	char *
	bm_traverse( char *expression, BMTraverseData *traverse_data )
	{
		BMTraverseCB **table = (BMTraverseCB **) traverse_data->table;
		BMTraverseCB *user_CB;
		char *	p = expression;
		int	flags = FIRST, done = 0;
		...	// BMBgnCB
		while ( *p && !done ) {
			...	// BMPreemptCB
			switch ( *p ) {
			...
			case '~':
				BMTraverseCB user_CB = table[ BMNegatedCB ];
				if (( user_CB )) {
					traverse_data->p = p; traverse_data->flags = flags;
					int retval = user_CB( traverse_data, p, flags );
					p = traverse_data->p; done = traverse_data->done;
					if (!( retval==BM_DONE ))
						f_set( traverse_data->flags )
					else break;
				}
				if is_f(NEGATED) f_clr( NEGATED )
				else f_set( NEGATED )
				p++; break;
			...
			}
		}
		...	// BMEndCB
		return p;
	}

Events & callback names association

	Events
		~ { } | * % ( , : ) ? ! . " ' / (+non-separator)

		Special combinations
			% followed by one of ,:)}|
			%(
			%?
			%!
			* followed by one of ,:)}|
			*
			(:
			informed ?
			.(
			.identifier
			identifier

	Callback Names
		See ./include/traverse.h

