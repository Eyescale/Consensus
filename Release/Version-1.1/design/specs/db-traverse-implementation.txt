
Call stack
	db_feel
		> db_verify
			> xp_verify
				> bm_verify
	db_traverse
		[ > xp_traverse ]
			> traverse_CB
				> db_verify
					> xp_verify
						> bm_verify
				> user_CB


Original Approach - simple, but not working

	The very firt db_traverse() implementation applied the following approach:

	1. get a set of candidates - from xp_traverse()
	2. for each candidate
		for each term of the expression
			verify that there is a term.exponent matching candidate,
			using xp_compare, which is now left unused in traversal.c
		end for
	   and for

	It didn't work, because the verification compared each term.exponent
	individually with the candidate, not considering that the match may
	involve different instances between each of the term.exponent sets


Version-1.0 Release - working, but complicated

	The proper approach was to start from the candidate and walk it all
	the way through the expression to verify that each and every expression
	term is matched by the candidate itself

	1. unmarked expression
		candidate verifies ( a, b ) if and only if
			candidate.sub[ 0 ] verifies a
			<=> a :: candidate.sub[ 0 ]
		    AND
			candidate.sub[ 1 ] verifies b
			<=> b :: candidate.sub[ 1 ]

	2. marked expression
	   candidate i verifies %( a, expr( ? ) ) if and only if
	   there EXISTS j in
		i.exponent( ? )
		where exponent( ? ) is ?'s exponent in expr
	   so that
		j.sub[ 0 ] verifies a
		<=> a :: j.sub[ 0 ]
	    AND
		j.sub[ 1 ] verifies ALL expr terms

	(and recursively)

	3. Examples
	3.1. i verifies %((a,(b,c)), ? ) if and only if
	     there EXISTS j in
		i.as_sub[ 1 ]
	     so that
		a :: j.sub[0].sub[0]
		b :: j.sub[0].sub[1].sub[0]
		c :: j.sub[0].sub[1].sub[1]	// Note: outside-in

	3.2. Now using the same expression as in 3.1. but with
		c = %(((d,e),?),f)
	     we have 

	     i verifies %((a,(b,%((d,e),?),f))), ? ) if and only if
	     there EXISTS j in
		i.as_sub[ 1 ]
	     so that
		a :: j.sub[0].sub[0]
		b :: j.sub[0].sub[1].sub[0]
		there EXISTS k in
			(j.sub[0].sub[1].sub[1]).as_sub[1].as_sub[0]	// Note: inside-out
		so that
			d :: k.sub[0].sub[0].sub[0]
			e :: k.sub[0].sub[0].sub[1]
			f :: k.sub[1]
	etc.

