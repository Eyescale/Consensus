
Execution Model / Narrative Registry
	The specs are a pre-requisite for most of the planned features implementation below.

File Format extensions
	1. line continuation	\  
		like this	// note that there can be space after backslash
	2. support % and * as standalone expression terms
		currently * is not supported as last character in expression (why?)
	3. single-character identifier entities - e.g. '\0', '(', '\xhh...' etc.
		cf. https://en.wikipedia.org/wiki/Escape_sequences_in_C
		=> modify input, output and expression traversal
	4. registry variable %?
	4.1. pre-requisite: execution model / narrative registry (specs)
	4.2.
		on ?: expression
		in ?: expression
		%?
	5. narrative definition
	5.1. pre-requisite: execution model / narrative registry (specs)
	5.2. modify readNarrative to generate list of narratives, instead of one
	5.3.
		: prototype	// Q: what if base narrative? can I have %argv there?
		this		// Q: what if base narrative?
		%arg		// replace later occurrences of %arg with %(this:exponent)
				// Q: what if base narrative?
		.variable	// replace later occurrence of variable with (this,variable)
				// Q: what if base narrative?
		%( )		// declaration: does nothing
		do .( expr )	// same as do ( this, (expr) )
				// Q: what if base narrative?

		=> Q: what if base narrative?

Input/Output interface
		do expression : "format" <	// input
		do > "format": expression	// output

	Where format can hold
		%_	represents any entity identifier (including relationship instances)
		%s	represents any base entity identifier (no relationship instance)
		%c	represents only single character entity identifier
		%%	represents %

	"format" can also be omitted, which defaults to "%_"

	Input will read the stream and behave according to the specified format
		%_	if an identifiable expression is read, it is instantiated
			and associated with the provided input expression via *
			otherwise, e.g. in the case of an unquoted separator other
			than * or %, input just ignores and reads on
		%s	will instantiate base entity, either as alphanumerical or
			single character identifier instance
		%s	will instantiate single character identifier instance.
		%%	will read and move on if and only if input matches

	if other characters are specified in the format, input will read and move
	on if and only if the character matches the input

	Notes
	. Eventually we would like to support e.g.
		do > "format": { expression1, expression2, ... }
		do { expression1, expression2, ... }: "format" <
	  but for now only one expression can be specified
	. Q: how to convert a ( list, * ) of single character identifier entities
	     into a standalone entity - aka. B% literal? could it be by piping output
	     into input? // Out of scope

