/*	so we have ( (*,A), ((A,A),A) )
	 & we have ( (*,((A,A),A)), ((((A,A),A),*),2) )
[E]	 & we have ( ((A,A),A), (A,A) ), ADD )

	Here we have *A=((A,A),A)
		but we have (A,A) which is *A.as_sub[0].sub[1]
			=> ((A,A),A) is *A.as_sub[0]^2
	*A = %((*,A),?) => A.as_sub[1].as_sub[0].sub[1]

	A.as_sub[1] = { (A,A), ((A,A),A), (*,A) }
	A.as_sub[1].as_sub[0] =
		(A,A).as_sub[0] = { ((A,A),A) }
		((A,A),A).as_sub[0] = { (((A,A),A),*), (((A,A),A),(A,A)) }
		(*,A).as_sub[0] = { ((*,A), ((A,A),A)) }
	A.as_sub[1].as_sub[0].sub[1] = { A, *, (A,A), ((A,A),A) }
	Now I have effectively 3 paths to reach '2' via *
		And if I remove [E] that still leaves two paths = from A or ((A,A),A)

		But if I use B as a variable I would have
		B.as_sub[1] = { (*,B) }
		B.as_sub[1].as_sub[0] = { ((*,B),((A,A),A) }
		B.as_sub[1].as_sub[0].sub[1] = { ((A,A),A) } => ONLY ONE PATH

		Likewise if I use (A,(A,A)) instead of ((A,A),A)

	=> NO BUG !
	FIX: ward off doublons BEFORE ->sub[1] and EXP
*/
#define A
// #define B
// #define SWAP
// #define TEST
#ifdef A
	on init
		do ( ( ((A,A),A), (A,A) ), ADD )
		do : A : ((A,A),A)
	else on : A : ?
		do : %? :((%?,*), 2 )
	else
		do >"%$\n":%((*A,*), ?:... )
		do exit
#eldef B
	on init
		do ( ( ((A,A),A), (A,A) ), ADD )
		do : B : ((A,A),A)
	else on : B : ?
		do : %? :((%?,*), 2 )
	else
		do >"%$\n":%((*B,*), ?:... )
		do exit
#eldef SWAP
/*	so we have ( (*,(A,(A,A))), (((A,(A,A)),*),2) )
	 & we have ( (*,A), (A,(A,A)) )
*/
	on init
		do ( ( (A,(A,A)), (A,A) ), ADD )
		do : A : (A,(A,A))
	else on : A : ?
		do : %? :((%?,*), 2 )
	else
		do >"%$\n":%((*A,*), ?:... )
		do exit
#endif

#ifdef TEST
	on init
		do (((A,*),...),<1,2,1,3,1>)
	else
		do >"%$\n":%((A,*),?:...)
		do exit
#endif
