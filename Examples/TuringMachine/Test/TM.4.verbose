on init
	do (( *, phase ), INPUT )
	do (( *, state ), INPUT_SEPARATOR )
	do input: <

else in *phase: INPUT
	on ((*,input), . )
		in *state: INPUT_SEPARATOR
			on (( *, input ), ~%(separator,(TM,?)))
				do ( separator, (TM,*input))
			else do (( *, state ), INPUT_BLANK )
		else in *state: INPUT_BLANK
			do (( *, BLANK ), (TM,*input))
			do (( *, state ), INPUT_RIGHT )
		else in *state: INPUT_RIGHT
			do (( *, RIGHT ), (TM,*input))
			do (( *, state ), INPUT_LEFT )
		else in *state: INPUT_LEFT
			do (( *, LEFT ), (TM,*input))
			do (( *, state ), CONTINUE )
		else in *state: CONTINUE
			do (( *, state ), ( INPUT_TUPLE, INITIAL ))
		else in *state: ( INPUT_TUPLE, INITIAL )
			do (( *, INITIAL ), (TM,*input))
			do (( *, q ), (TM,*input))
			do (( *, state ), ( INPUT_TUPLE, INPUT_SYMBOL ))
		else in *state: ( INPUT_TUPLE, INPUT_SYMBOL )
			do (( *, s ), (TM,*input))
			do (( *, state ), ( INPUT_TUPLE, OUTPUT_SYMBOL ))
		else in *state: ( INPUT_TUPLE, OUTPUT_SYMBOL )
			do (( *, (SYMBOL,(*q,*s))), (TM,*input))
			do (( *, state ), ( INPUT_TUPLE, OUTPUT_MOTION ))
		else in *state: ( INPUT_TUPLE, OUTPUT_MOTION )
			do (( * , (MOTION,(*q,*s))), (TM,*input))
			do (( *, state ), ( INPUT_TUPLE, OUTPUT_STATE ))
		else in *state: ( INPUT_TUPLE, OUTPUT_STATE )
			do (( *, (STATE,(*q,*s))), (TM,*input))
			do (( *, state ), ( INPUT_TUPLE, INPUT_STATE ))
		else in *state: ( INPUT_TUPLE, INPUT_STATE )
			on (( *, input ), ~%(separator,(TM,?)))
				do (( *, q ), (TM,*input))
				do (( *, state ), ( INPUT_TUPLE, INPUT_SYMBOL ))
			else
				do (( *, p ), START )
				do (( *, state ), INPUT_TAPE )
		else in *state: INPUT_TAPE
			on (( *, input ), ~%(separator,(TM,?)))
				in (( *, input ), %(STATE,((TM,?),.)))
					do (( *, INITIAL ), (TM,*input))
					do CHECK
				else
					do (( *, p ), (*p,(TM,*input)))
					in CHECK
						do (( *, START ), (*p,(TM,*input)))
						do ~( CHECK )
			else
				do > ">> separators: "
				do >: %(separator,(TM,?))
				do >:
				do > ">> controls: { "
				do >: %((TM,?):*BLANK)
				do > ", "
				do >: %((TM,?):*RIGHT)
				do > ", "
				do >: %((TM,?):*LEFT)
				do > " }\n"
				do > ">> output states: "
				do >: %((.,?):*(STATE,.))
				do >:
				do > ">> input states: "
				do >: %((.,?):%(STATE,(?,.)))
				do >:
				do > ">> initial mood: "
				do >: %((.,?):*INITIAL)
				do >:
				do > ">> final mood(s): "
				do >: %((.,?):*(STATE,.):~%(STATE,(?,.)))
				do >:
				do (( *, (head,state)), *INITIAL )
				do ( FINAL, *(STATE,.):~%(STATE,(?,.)))
				in ( START, . )
					do (( *, p ), %(START,.))
					do (( *, phase ), OUTPUT_INIT )
				else
					do >">> blank tape\n"
					do (( *, START ), (START,*BLANK))
					do (( *, (head,position)), (START,*BLANK))
					do (( *, phase ), RUN )
	else in ( *, input )
		do input: <
	else
		do >"Error: File Format: unexpected EOF\n"
		do exit

else in *phase: OUTPUT_INIT
	on ((*,phase), OUTPUT_INIT )
		do >">> initial tape:\n"
	on ((*,p), . )
		do > "\tsymbol:%_": %((.,?):*p)
		do > "\tright:%_": %(*p,.)
		do >:
	else in ( *p, . ) // check next p
		do (( *, p ), %(*p,.))
	else
		do (( *, p ), %(START,.))
		do (( *, phase ), DATA_PREP )

else in *phase: DATA_PREP
	on ((*,p), . )
		// set TAPE value (TM,.) at position p
		do (( *, (TAPE,*p)), %((.,?):*p))
		// set RIGHT value (position) at position p
		do (( *, (RIGHT,*p)), %(*p,.))
		do (( *, (LEFT,%(*p,.))), *p )
	else in ( *p, . )
		do (( *, p ), %(*p,.))
	else
		in ((*,START), . )
			do (( *, (head,position)), *START )
		else
			do (( *, (head,position)), %(START,.))
			do (( *, START ), %(START,.))
		do (( *, phase ), RUN )

else in *phase: RUN
	on ((*,(head,position)), . )
		do > "\nHEAD mood: %_": %((.,?):*(head,state))
		do >:
		in ( LEFT, *(head,position))
			// assign p to the left position which has no left
			do (( *, p ), *(LEFT,.):~%(LEFT,?))
		else do (( *, p ), *(head,position))
		do (( *, phase ), OUTPUT )
	else on ~((*,phase), OUTPUT  )
		in ( FINAL, *(STATE,*index))
			do > "HEAD mood: %_": %((.,?):*(STATE,*index))
			do > " (final)\n"
			do exit
		else in ( TAPE, *(head,position))
			do (( *, symbol ), *(TAPE,*(head,position)))
		else do (( *, symbol ), *BLANK )
	else on ((*,symbol), . )
		do > "TAPE symbol: %_": %((.,?):*symbol)
		do >:
		in ( *(head,state), *symbol )
			do (( *, index ), (*(head,state),*symbol))
		else
			do >"Error: transition undefined\n"
			do exit
	else on ((*,index), . )
		// fetch or create TAPE entry at *(head,position), and
		// assign SYMBOL entry value at index to entry
		do > "HEAD symbol: ": %((.,?):*(SYMBOL,*index))
		do >:
		do (( *, (TAPE,*(head,position))), *(SYMBOL,*index))

		// assign MOTION entry value at index to entry
		do > "TAPE move: %_": %((.,?):*(MOTION,*index))
		do >:
		do (( *, motion ), *(MOTION,*index))

		// assign STATE entry value at index to (head,state)
		do (( *, (head,state)), *(STATE,*index))
	else on ((*,motion), . )
		do > "HEAD mood: %_": %((.,?):*(head,state))
		do >:
		in *motion: *RIGHT
			in ( RIGHT, *(head,position ))
				do (( *, (head,position)), *(RIGHT,*(head,position)) )
			else // create new TAPE position and table entry
				do (( *, (new,p)), (RIGHT,*(head,position)))
		else in *motion: *LEFT
			in ( LEFT, *(head,position ))
				do (( *, (head,position)), *(LEFT,*(head,position)) )
			else // create new TAPE position and table entry
				do (( *, (new,p)), (LEFT,*(head,position)))
	else on ((*,(new,p)), . )
		in *motion: *RIGHT
			do (( *, (RIGHT,*(head,position))), *(new,p))
			do (( *, (LEFT,*(new,p))), *(head,position))
		else in *motion: *LEFT
			do (( *, (LEFT,*(head,position))), *(new,p))
			do (( *, (RIGHT,*(new,p))), *(head,position))
	else // update head position
		do (( *, (head,position)), *(new,p))

else in *phase: OUTPUT
	on ((*,p), . )
		in *p: *START
			do >"|"
		do (( *, state ), OUTPUT_CURRENT )
	else in *state: OUTPUT_CURRENT
		in *p: *(head,position)
			do >: %((.,?):*(head,state))
		else do >" "
		do (( *, state ), OUTPUT_SYMBOL )
	else in *state: OUTPUT_SYMBOL
		in ( TAPE, *p )
			do >: %((.,?):*(TAPE,*p))
		else do >: %((.,?):*BLANK)
		do >" "
		do ~( *, state )
	else in ( RIGHT, *p )
		do (( *, p ), *(RIGHT,*p))
	else
		do >:
		do (( *, phase ), RUN )

/* Example output:
        |.0     start from blank tape
        .0|1    moves left
        0|.1    moves right
        0|0.0   moves further right

        not shown here: *state
*/

